@import url('https://fonts.googleapis.com/css?family=Montserrat+Alternates|Raleway');


p {
   color:#29A33F;                 /* цвет шрифта */
   font-size:100%;               /* размер шрифта */
   font-family:  "Montserrat Alternates","Raleway";   /* шрифт */
   background-color:#EBEBED;        /* цвет фона */
}

#intro .first {
    background-color:pink;
}

#intro .first em {
   color: red; 
   background-color:yellow;
}

/* Свойство font-style обычно используется для применения курсивного начертания к тексту. */

.italic {
   font-style: italic;
}

/* Свойство font-weight управляет толщиной текста. Могут быть установлены значения normal 
(размер по умолчанию), bold, bolder, и lighter.*/

.light {   
   font-weight: lighter;
}
.bold {   
   font-weight: bold;
}
.bolder {
   font-weight: bolder;
}

/*Если необходимо, можно задать толщину шрифта с помощью числа от 100 (тонкий) до 900 (жирный).
400 это то же самое, что normal, а 700 то же самое, что bold. */


/*Свойство font-variant

Свойство CSS font-variant позволяет вам конвертировать ваш шрифт в маленькие заглавные
буквы. Значениями могут быть установлены normal, small-caps, и inherit. */

.normal {
   font-variant: normal;
}
.small {
   font-variant: small-caps;
   font-weight: bolder;
}

/*
Свойство text-align определяет горизонтальное расположение текста в элементе. 
По умолчанию, текст на вашем веб-сайте выравнен по левому краю. Однако, вам может 
понадобиться иное расположение. 

Значениями свойства text-align являются: left, right, center, и justify.

Если свойство text-align включено на "justify", то каждая строка растягивается таким 
образом, что будет иметь равную ширину, а левое и правое поля будут ровными 
(как в журналах и газетах).*/

.left {
   text-align: left;
}

.center {
   text-align: center;
}
.right {
   text-align: right;
}

/*Свойство vertical-align

Свойство vertical-align устанавливает вертикальное положение элемента. 
Используемыми значениями являются top, middle, и bottom.

В нижеуказанном примере отображено, как вертикально располагать текст в таблице. 
*/

.top {
    color:#29A33F;   
    vertical-align: top;
}
.middle {
    color:#29A33F; 
    vertical-align: middle;
}
.bottom {
    color:#29A33F; 
    vertical-align: bottom;
}

/* Свойство vertical-align также принимает следующие 
значения: baseline, sub, super, % и px (или pt, cm). 
В нижеуказанном примере отображена разница между ними. */

.baseline {
    vertical-align: baseline;
}
.sub {
    vertical-align: sub;
}
.super {
    vertical-align: super;
}
.pixel {
    vertical-align: -10px;
}


/*  
Свойство расположения по вертикали не действует одинаково на все элементы.
Например, дополнительная CSS стилизация необходима для элементов div. 

display: inline-table; и display: table-cell; правила применяются для 
работы свойства vertical-align с divs. */ 

.main {
    height: 100px; width: 400px;
    background-color: #29A33F;
    display: inline-table;
}
.paragraph {
    display: table-cell;
    vertical-align: middle;
}


/* Свойство text-decoration

Свойство text-decoration определяет, как будет декорирован текст. 

Наиболее часто используемые значения:
none - Значение по умолчанию, определяет нормальный текст 
inherit - Наследует это свойство от его родительского элемента 
overline - Рисует горизонтальную линию над текстом
underline  - Рисует горизонтальную линию под текстом
line-through - Рисует горизонтальную линию сквозь текст (заменяет HTML тег <s> )

В нижеуказанном примере продемонстрирована разница между каждым значением.

Вы можете комбинировать значения underline, overline, или line-through указывая
их через пробел, чтобы добавить несколько линий.*/ 


.none {
   text-decoration: none;
}
.inherit {
   text-decoration: inherit;
}
.overline {
   text-decoration: overline;
}
.underline {
   text-decoration: underline;
}
.line-through {
   text-decoration: line-through;
}


/* Другим значением свойства text-decoration является blink которое заставляет 
текст мигать.
Данное значение является доступным, но не рекомендуется к использованию,
поэтому большинство браузеров его игнорируют.

CSS синтаксис выглядит следующим образом:   */ 

.blink {
        text-decoration: blink; 
}        


/*  Свойство text-indent

Свойство text-indent определяет, сколько места по горизонтали должно быть
оставлено до начала первой строки текста. Значениями свойства 
являются length (px, pt, cm, em, и т.д.), %, и inherit. 

Также разрешено использование отрицательных значений.
Первая строка будет выровнена по левому краю, если значение является отрицательным.*/ 
 
.indent {
   text-indent: 60px;
}
 
 

/*  Свойство text-shadow

Свойство text-shadow добавляет к тексту тень. 
Оно принимает четыре значения: первое значение определяет длину 
тени по оси x (по горизонтали), второе значение определяет длину 
по оси y (по вертикали), третье значение определяет размытие тени, 
а четвертое значение определяет цвет. 


В нижеуказанном примере мы создали тень со следующими параметрами:
5px - X-координата
2px - Y-координата 
4px - радиус размытия
grey - цвет тени

Чтобы добавить более одной тени тексту, добавьте список теней, разделенных запятыми.*/ 
 
h1 {
   color: #29A33F;
   font-size: 30pt;
   text-shadow: 5px 2px 4px grey;
}
 
 

/* эффект размытия свойства text-shadow

При работе с тенями вы можете использовать любые поддерживаемые CSS цветовые форматы.

Для значений x и y могут применяться различные единицы 
измерений (как px, cm, mm, in, pc, pt, и т.д.). 
Отрицательные значения также доступны для использования.

В нижеуказанном примере создается синяя тень, которая на два пикселя
выше основного текста, на один пиксель левее его и с радиусом размытия 0.5em: 
  */ 

.blur {
   font-size: 20pt;   
   text-shadow: rgba(0,255,0,1) -1px -2px 0.5em; 
}

/*  Свойство text-transform

CSS свойство text-transform определяет регистр текста. Например,
с его помощью можно сделать каждое слово в тексте с заглавной буквы. */ 

.capitalize {
   text-transform: capitalize;
}


/*  Значения text-transform

Используя свойство text-transform, вы может изменить регистр всего 
текста на нижний или верхний. Например: */ 

.uppercase {
   text-transform: uppercase;
}
.lowercase {
   text-transform: lowercase;
}

/*  Свойство letter-spacing

Свойство letter-spacing определяет расстояние между символами в тексте. 
Значениями могут быть:
- normal определяет стиль по умолчанию, без дополнительного расстояния между символами
- length определяет дополнительное расстояние между символами, с помощью единиц 
  измерения px, pt, cm, mm, и т.д.;
- inherit наследует значения родителя;  */ 

.normal { 
   letter-spacing: normal; 
}
.positive { 
   letter-spacing: 4px; 
}


/* Использование Отрицательных Значений

Использование отрицательных значений также разрешено для определения расстояния
между символами. 
Обратите внимание на пример разницы между использованием положительных и отрицательных
значений: */ 

.positive { 
   letter-spacing: 4px; 
}
.negative { 
   letter-spacing: -1.5px; 
} 


/* Свойство word-spacing

Свойство word-spacing определяет расстояние между словами в тексте. 
Также, как и в свойстве letter-spacing, вы можете использовать значения normal,
length, и inherit.   

Когда было использовано странное расстояние между словами,
а необходимо, чтобы выбранный параграф имел нормальное расстояние 
между словами, следует использовать значение normal.  */ 

.normal { 
   word-spacing: normal;
}
.px { 
   word-spacing: 30px;
}



/*  Единицы Измерений

Для определения дополнительного расстояния между словами вы можете использовать
положительные значения в таких единицах 
измерений, как px, pt, pc, cm, mm, inches, em, и ex.
Использование отрицательных значений также разрешено. Обратите внимание 
на пример разницы их использования. 
 */

.positive2 { 
   word-spacing: 20px;
}
.negative2 { 
   word-spacing: -5px;
}



/*  Свойство white-space

Свойство white-space определяет, как будут отображаться пробелы внутри элемента.
Значениями могут быть normal, inherit, nowrap, и т.д. 

Значение nowrap игнорирует все переносы строк элемента. 

Текст будет отображаться одной строкой, пока не встретится тег <br />.
 */ 

.white-space {
   white-space: nowrap;
}



/* Значения свойства white-space

Свойство white-space также поддерживает другие значения:
pre - текст показывается с учетом всех пробелов и переносов
pre-line - текст будет перенесен на следующую строку, при соответствующей
команде в коде, пробелы игнорируются
pre-wrap - в тексте сохраняются все пробелы и переносы

Обратите внимание на пример, в котором использованы все три значения:

Значение pre-wrap ведет себя также, как и
значение pre , не считая того, что оно добавляет дополнительные переносы строк, 
в случае, если строка по ширине не помещается в заданную область.
  */ 


.pre {
   white-space: pre;
}
.preline {
   white-space: pre-line;
}
.prewrap {
   white-space: pre-wrap;
}



/* Блочная Модель языка CSS

Все HTML элементы могут быть представлены как блоки. Блочная модель
языка CSS представляет собой дизайн и макет сайта. Она состоит из внешних отступов,
рамок, внутренних полей, и актуального контента. 

Свойства работают в таком же порядке: верх, право, низ, и лево. 

В нижеуказанной схеме отображена работа блочной модели:   */ 


#div0 {
    width: 400px;
    height: 300px;
}

/* Еще о Блочной Модели

Каждый элемент вебстраницы является блоком. 

CSS использует блочную модель для определения, насколько большой блок и как его 
разместить.
 
Блочная модель также используется для того, чтобы посчитать актуальную 
ширину и высоту HTML элементов. 

Общая Ширина Элемента

При работе с блоками важно понимать, как считается общая ширина элемента. 
Например, общая ширина блока с внутренними полями будет равна сумме 
ширины плюс левое внутреннее поле и правое внутреннее поле.


Вот другой блок с внешними отступами, границей и внутренними полями. 
Общая ширина равна сумме левого и правого внутреннего отступа, левой 
и правой границы, левого и правого внутреннего поля, и актуальной ширины контента.

При установке свойств ширины и высоты элемента с помощью CSS, вы устанавливаете 
ширину и высоту области контента.
При установке фонового цвета в блок, он покрывает область контента,
вместе с внутренними полями.

Общая высота элемента высчитывается таким же образом, как и ширина. 
В нижеуказанном примере тот же самый блок из предыдущего урока, 
с внутренними полями, рамкой и внешними отступами. 

Для обобщения, Общая высота элемента = высота + верхнее внутреннее 
поле + нижнее внутреннее поле + верхняя граница + нижняя граница + верхний 
внешний отступ + нижний внешний отступ*/ 

#div1 {
    width: 400px;
    height: 300px;
}

#div2 {
    width: 400px;
    height: 300px;
}

#div3 {
    width: 400px;
    height: 300px;
}


/* Свойство border

CSS свойство border позволяет вам изменять рамки HTML элементов.
Чтобы добавить рамку к элементу, вам необходимо определить размер, стиль, и цвет рамки. 
В нижеуказанном примере отображено, как добавить сплошную зеленую рамку к параграфу.
  */ 

#border {
   padding: 10px;    
   border: 3px solid #13A8D1;
}


/*  Ширина Рамки

Свойства рамок могут быть установлены отдельно. Свойство border-width 
устанавливает ширину рамки.
 */ 

.first {
   padding: 10px;    
   border-style: solid 255;
   border-width: 2px;
}
.second {
   padding: 10px;    
   border-style: solid;
   border-width: 5px;
}


/* Цвет Рамки

Цвет рамки элемента может быть определен с помощью названия цвета, RGB,
или шестнадцатеричного значения. 
HTML:   

Свойства рамки не будут работать, пока не будет установлено свойство border-style.*/ 


.first1 {
   padding: 10px;
   border-style: solid;
   border-width: 2px;
   border-color: blue;
}
.second1 {
   padding: 10px;    
   border-style: solid;
   border-width: 2px;
   border-color: #FF6600;
} 
.third1 {
   padding: 10px;    
   border-style: solid;
   border-width: 2px;
   border-color: rgb(0, 255, 0);
} 


/*  Свойство border-style

Значением по умолчанию свойства border-style является none, которое определяет
отсутствие рамки. 
Существует несколько стилей, поддерживаемых свойством border-style: dotted(точечный),
dashed(пунктирный), double(двойной), и т.д. В нижеуказанном примере отображены отличия
между ними. 


В CSS возможно определить различные рамки для разных сторон, используя следующие свойства:
border-top-style(стиль верхней рамки), border-right-style(стиль правой рамки), 
border-bottom-style(стиль нижней рамки), и border-left-style(стиль левой рамки) 
для соответствующих сторон. */ 

.none {border-style: none;}
.dotted {border-style: dotted;}
.dashed {border-style: dashed;}
.double {border-style: double;}
.groove {border-style: groove;}
.ridge {border-style: ridge;}
.inset {border-style: inset;}
.outset {border-style: outset;}
.hidden {border-style: hidden;}




/*  Определение Ширины и Высоты в CSS

Чтобы установить ширину и высоту элемента <div> равной 200px, необходимо:

Общая ширина блока будет равна 190px+5px (рамка)+5px(рамка) = 200px; */ 
 
#div4 {
   border: 5px solid green; 
   color:#29A33F;
   width: 190px;
   height: 190px;
}
 

/* Измерение Ширины и Высоты

Ширина и высота элемента может быть также присвоена с помощью использования процентов. 
В нижеуказанном примере ширина элемента задана в процентах, а высота в пикселях. 
  */ 

#div5 {
   border: 5px solid green;    
   color:#29A33F;
   width: 100%;
   height: 90px;
}

/* Минимальный и Максимальный размеры

Для того, чтобы установить минимальную и максимальную высоту и ширину элемента,
вы можете использовать следующие свойства:

min-width - минимальная ширина элемента
min-height - минимальная высота элемента
max-width - максимальная ширина элемента
max-height - максимальная высота элемента

В нижеуказанном примере, мы установили минимальную высоту и максимальную ширину 
различных параграфов равных 150px. 
  */ 

.first1 {
   border: 5px solid green;    
   min-height: 150px;       
}
.second1 {
   border: 5px solid green;    
   max-width: 150px;       
}


/*  Свойство background-color

Свойство background-color используется для установки фонового цвета элемента. 
 
 
body {
    background-color: white;
} 
 
 */
/*  Значения Фонового Цвета

Фоновый цвет может быть определен с помощью трех разных форматов:  названия цвета,
шестнадцатеричного значения, и RGB. 

В нижеуказанном примере, элементам body, h1, и p присвоены различные фоновые цвета:  */ 

body {
   background-color: white;
}
.h11 {
   background-color: rgb(135,206,235);
}
.p11 {
   background-color: LightGreen;
}

/*  Свойство background-image

Свойство background-image устанавливает одно или несколько фоновых изображений в элементе.
Давайте установим фоновое изображение для элемента <body>.
По умолчанию, фоновое изображение размещается в левом верхнем углу элемента и повторяется
вертикально и горизонтально, чтобы покрыть весь элемент.
 */ 

body {
   background-image: url("https://d9me64que7cqs.cloudfront.net/images/common/footer-bg-md-aee55c2ff093742fb9a35c21940a26401d0f21def1d4a4618cd31b9b70173cad53f65952068efe246d4b22d6e8fcbae4e828b07f49dd83106d067fbe1e65b20f.jpg");
   background-color: #e9e9e9;
   background-attachment: fixed;
}

/* Свойство background-image

Фоновое изображение может быть установлено не только для всей страницы, но также и для
отдельного элемента. 
Ниже мы установим фоновое изображение для элемента <p>. 
Чтобы указать более одного изображения необходимо лишь перечислить их  URL через запятые. */ 
  
#p_img {
   padding: 30px;
   background-image: url("https://d1u1mce87gyfbn.cloudfront.net/hero/mercy/full-portrait.png");
   background-size: 50px;
   color: #29A33F;   
}  

/*  Свойство background-repeat

Свойство background-repeat определяет, как будет повторяться фоновое изображение. 
Можно установить повторение рисунка по горизонтали, по вертикали, в обе стороны или 
чтобы он не повторялся вообще. 

Значение repeat-x будет повторять фоновое изображение только горизонтально. 
 */ 
 
#p_img1 {
   padding: 30px;
   background-image: url("https://d1u1mce87gyfbn.cloudfront.net/hero/mercy/full-portrait.png");
   background-size: 20px;
   background-repeat: repeat-x;  
}
 

/* Значение repeat-y будет повторять фоновое изображение только вертикально. 
 Если вы хотите, чтобы изображение было показано только один раз, 
 используйте значение no-repeat. */ 

#p_img2 {
   padding: 30px;
   background-image: url("https://d1u1mce87gyfbn.cloudfront.net/hero/mercy/full-portrait.png");
   background-size: 20px;
   background-repeat: repeat-y;
 
}

/*  Установка значения для Наследования

При установке свойства background-repeat на inherit, оно будет принимать такое же значение, 
как и свойство для родителя элемента. 

Например, мы установим фон элемента body, чтобы он повторялся только горизонтально. 
Если мы установим значение свойства background-repeat какого-нибудь параграфа чтобы оно 
наследовалось, то оно будет равно значению свойства элемента body.

body {
   background-image: url("css_logo.png");
   background-repeat: repeat-x;
}  */

#bg_img {
   background-image: url("https://d9me64que7cqs.cloudfront.net/images/common/footer-bg-md-aee55c2ff093742fb9a35c21940a26401d0f21def1d4a4618cd31b9b70173cad53f65952068efe246d4b22d6e8fcbae4e828b07f49dd83106d067fbe1e65b20f.jpg");
   background-repeat: inherit;
   margin-top: 10px;
   padding: 40px;
}

 

/* Свойство background-attachment

Свойство background-attachment устанавливает, будет ли прокручиваться фоновое изображение 
вместе с содержимым элемента.
Даже, если элемент имеет прокручивающийся механизм, "фиксированное" фоновое изображение
не будет двигаться с элементом.

body {
   background-image: url("css_logo.png");
   background-repeat: no-repeat;
   background-attachment: fixed;
}


   Значения свойства background-attachment

Вы также можете настроить свойство background-attachment для наследования(inherit) 
или перемещения вместе с содержимым(scroll).
Если вы установите значение свойства background-attachment на inherit, то оно наследует 
значение его родительского элемента. 

Если вы установите свойство background-attachment на scroll, то фоновое изображение будет
перемещаться вместе с содержимым.

body {
   background-image: url("css_logo.png");
   background-repeat: no-repeat;
   background-attachment: scroll;
}   */ 

/*  Свойство list-style-type

CSS свойства list позволяют нам устанавливать различные списки маркеров. 
В HTML существует два типа списков:
unordered lists(неупорядоченные списки) (<ul>) - элементы списка обозначаются маркерами
ordered lists(упорядоченные списки) (<ol>) - элементы списка обозначаются числами, или буквами
В CSS, списки могут быть стилизованы дальше, а изображения могут использоваться в качестве 
элементов списка.
Одним из способов является использование свойства list-style-type, которое может быть 
установлено на circle, square, decimal, disc, lower-alpha, и т.д. 
 */ 
 
.lower-alpha {
   color:#29A33F;
   list-style-type: lower-alpha;
}
.circle {
   list-style-type: circle;
   color:#29A33F; 
}
.square {
   list-style-type: square;
   color:#29A33F; 
} 
 

/*  Изображение Списка и Позиция

Существуют также и другие свойства для списков, например:
list-style-image - устанавливает изображение в качестве маркера списка.
list-style-position - устанавливает, как будет размещаться маркер относительно 
текста (внутри, снаружи).

В нижеуказанном примере, мы используем изображение в качестве маркера списка и определяем
положение внутри содержимого. 
 */ 
 
.point_img {
   color:#29A33F;
   list-style-image: url("http://www.sololearn.com/images/bullet.jpg");
   list-style-position: inside;
} 
 

/* Свойство list-style

Свойство list-style это универсальное свойство для установки list-style-type(типа), 
list-style-image(изображения) и list-style-position(положения). 
Оно используется для установки всех трех свойств в одном объявлении:   

ul {
   list-style: square outside none;
}

Также, как и в полной(длинной) версии. 
ul {
   list-style-type: square;
   list-style-position: outside;
   list-style-image: none;
}*/ 



/* Свойства Таблиц

Вид HTML таблиц может быть улучшен с помощью CSS.

Свойство border-collapse определяет, будет ли рамка таблицы объединена в одну линию, 
или у каждой ячейки будет своя рамка. Если рамки разделены, то может быть использовано 
свойство border-spacing для изменения расстояния между границами ячеек в таблице. 
  */ 

#table1 {
   border-collapse: separate;
   border-spacing: 20px 40px;
   color:#29A33F; 
}



/*  Свойство caption-side

Свойство caption-side определяет положение заголовка таблицы. Значениями могут быть 
установлены top(вверху) или bottom(внизу). 
В указанном ниже примере, мы определим положение заголовка таблицы вверху.
 */ 

caption {
   caption-side: top;
   color:#29A33F; 
}

th {
   color:#29A33F; 
}   

td {
   color:#29A33F; 
}   

/* Свойство empty-cells

Свойство empty-cells определяет, отображать рамки и фон пустых ячеек в таблице, или нет. 
Значениями могут быть:
show: отображает границу вокруг ячейки и фон в ней
hide: граница и фон в пустых ячейках не отображаются

Далее представлено использование свойства empty-cells, которое прячет рамки пустых ячеек 
в элементе <table>.
  */ 

#table5 {
   border-collapse: separate;
   empty-cells: hide;
}


/* Свойство table-layout

Свойство table-layout определяет, каким образом подсчитывается ширина столбцов таблицы. 
Возможными значениями являются:
auto - в случае, если ширина столбца или ячейки не задана точно, она будет зависеть от 
количества содержимого ячейки 
fixed - в случае, если ширина столбца или ячейки не задана точно, количество содержимого 
ячейки не будет влиять на ее ширину.

Шаблон таблицы по умолчанию имеет значение auto. 
В нижеуказанном примере отображено отличие между значениями auto и fixed. 
  */ 

table {
   border-collapse: separate;
   border: 1px solid gray;
} 
td {
   border: 1px solid gray;
}
.auto {
   table-layout: auto;
}
.fixed {
   table-layout: fixed;
}

/*  Установка Стиля Ссылкам

Ссылки могут быть стилизованы с помощью любых CSS свойств (например color, font-family, 
background, и т.д.).
Также, ссылки могут быть стилизованы по-другому, в зависимости от того, в каком они состоянии. 
Доступны следующие псевдо-селекторы:
a:link - определяет стиль для нормальных не посещённых ссылок 
a:visited - определяет стиль для посещённых ссылок 
a:active - ссылка становится активной при нажатии на неё 
a:hover - активизируется, когда курсор мыши находится в пределах элемента

В нижеуказанном примере создается ссылка, стиль которой будет меняться, когда курсор мыши 
будет находится в ее пределах.
 */ 

#my_site a:hover {
   color: red;
}


/* Декорирование Текста Ссылки

По умолчанию, ссылки подчеркиваются браузером.
Одним из наиболее общих использований CSS к ссылкам является удаление нижнего подчеркивания. 
В нижеуказанном примере, свойство text-decoration используется для удаления нижнего подчеркивания. 


Следующие свойства используются для управления отображением ссылок:
border:none - убирает рамку изображений с ссылками
outline:none - убирает пунктирную рамку с нажатых строк в браузере IE */ 

#my_site1 a:link {
   text-decoration: none;
}



/* Устанавливаем Стиль Курсора Мыши

CSS позволяет вам установить желаемый стиль курсора при проведении мышкой над элементом. 
Например, вы можете изменить ваш курсор в иконку руки, иконку помощи и в другие, вместо использования указателя по умолчанию. 

В нижеуказанном примере, указатель мыши становится иконкой помощи при проведении мыши над элементом:
  */ 

#span_my {
   color: green
}



/* Значения Свойства cursor

Существует еще множество других возможных значений для свойства cursor, например:
default – курсор по умолчанию
crosshair – курсор отображается как перекрестие
pointer – курсор отображается как иконка руки 
Список возможных значений довольно большой. Ниже отображены различные доступные стили:   */ 

#div7 {
   width: 50%;
   height: 50%;
}

/* Значение по умолчанию

Обычно, вид курсора мыши изменяется для создания хорошего впечатления посетителям вебсайта.
Однако, использование неправильного курсора может ввести в заблуждение. 

Например, если значение курсора установлено на default (по умолчанию), 
пользователи могут не "видеть" ссылки.  */ 



/* display: block

Каждый элемент на веб странице является прямоугольным блоком. Свойство display определяет 
поведение этих блоков. Элемент блока это элемент, который занимает полностью доступную ширину, 
с переносами строк до и после.
Правила стиля в следующем примере отображают строчные элементы <span> в качестве блочных элементов:
  */ 

#my_block {
   color: green;
   display: block;
}

/* display: inline

Элемент inline только занимает достаточную ширину, но не использует переносы строк.
CSS: 

Установка свойства элемента display изменяет только отображение элемента, но не вид самого элемента.
Поэтому, строчный элемент с display:block не может иметь другие блочные элементы внутри.*/ 

#my_inline{
   display: inline;
}

/*  display:none

display:none прячет элемент так, что он не занимает места. Элемент будет спрятан, 
а страница будет отображена так, как будто элемента нет совсем.

h1 {
   display: none;
}


Еще много других значений свойства display, таких как list-item, table, table-cell, 
table-column, grid, и т.д. Просто поиграйте со значениями, чтобы увидеть разницу.
*/ 



/*  Свойство visibility

Свойство visibility определяет, будет элемент виден, или спрятан. Наиболее общими значениями
являются visible и hidden. 

Скрытие элемента может быть выполнено с помощью установки свойства display на "none", 
или свойства visibility на "hidden". Однако, обратите внимание, что эти два метода дают 
разные результаты:
visibility:hidden прячет элемент, но он все равно будет занимать столько же места, 
сколько и раньше. Элемент будет спрятан, но он будет влиять на разметку:
Пример:
 */ 

/* Свойство visibility

Свойство visibility определяет, будет элемент виден, или спрятан. Наиболее общими значениями 
являются visible и hidden. 

Скрытие элемента может быть выполнено с помощью установки свойства display на "none",
или свойства visibility на "hidden". Однако, обратите внимание, что эти два метода дают 
разные результаты:
visibility:hidden прячет элемент, но он все равно будет занимать столько же места, 
сколько и раньше. Элемент будет спрятан, но он будет влиять на разметку:
Пример:


#hidden {
   visibility: hidden;
}

  */ 

/* display:none прячет элемент, не оставляя для него места. 

Изменение visibility: hidden; на display: none; даст следующий результат:  

div.hidden {
   display: none;
}*/ 



/* Позиционирование Элементов

Свойства позиционирования CSS позволяют вам изменять положение элемента. 
Можно также размещать один элемент возле другого, и определять, что произойдет,
если содержимое элемента слишком велико.

Элементы можно позиционировать с помощью свойств top, bottom, left, и right. Однако, 
эти свойства не будут работать, пока сперва не будет установлено свойство position. 
Они также работают различным образом, в зависимости от метода позиционирования.


Нормальное Позиционирование

HTML по умолчанию для позиционирования использует значение static. Элемент выводится 
в потоке документа как обычно.

Нормальное Позиционирование

HTML по умолчанию для позиционирования использует значение static. Элемент выводится
в потоке документа как обычно.
Свойства top, bottom, left, и right игнорируются в нормальном позиционировании.  */ 

#position_static {
   position:static;
   top: 30px;
   right: 5px;
   color: red;
}

/* Фиксированное Позиционирование

Элемент с фиксированной позицией размещается относительно окна браузера, и не будет двигаться,
даже при прокрутке окна браузера.
Позиция может быть определена с помощью свойств top, right, bottom, и left. 
В примере ниже, параграф зафиксирован на 30px сверху и на 5px справа.*/ 
 
#position_fixed2 {
   position: fixed;
   top: 1px;
   right: 5px;
   color: red;
}

/*Элементы с фиксированной позицией убираются из нормального потока. 
Документ и другие элементы ведут себя так, будто элемент с фиксированной позицией не существует.
Элементы с фиксированной позицией могут перекрывать другие элементы.*/ 


/* Относительное Позиционирование

Положение элемента задается относительно его исходного места. 
Свойства top, right, bottom, и left могут использоваться для определения сдвига элемента. 


p {
   width: 350px;
   border: 1px black solid;
   position: fixed;
}
span {
   background: green;
   color:white;
   position: relative;
   top: 150px;
   left: 50px;
} 

Содержимое относительно позиционированных элементов может перемещаться и перекрывать другие элементы,
но зарезервированное место для элемента сохраняется в нормальном потоке.

Это значение не может быть использовано для ячеек таблиц, колонок, групп колонок, строк, групп строк,
или заголовков.

Абсолютное Позиционирование

Элемент абсолютного позиционирования расположен относительно первого родительского элемента, 
который имеет любое, но не нормальное, положение. Если таковой элемент не найден, 
то содержащий блок это <html>.

Абсолютно позиционированные элементы убраны из нормального потока. Документ и другие
элементы ведут себя так, будто абсолютно позиционированные элементы не существуют.

Абсолютно позиционированные элементы могут перекрывать другие элементы.

*/ 



/* Обтекание

Со свойством CSS float, элемент может быть выравнен по левому или правому краям, 
позволяя всем остальным элементам обтекать его вокруг.
Float часто используется с изображениями, но оно также полезно при работе с разметкой.
Значениями свойства float являются left, right, и none. 
Значения left и right свойства float выравнивают элементы в соответствующих направлениях 
(по левому и правому краям). none (по умолчанию) гарантирует, что элемент не будет обтекать. 
Ниже представлен пример изображения, которое выравнено по правому краю с помощью свойства float.  

Элементы обтекаются горизонтально, это значит, что элемент может быть выравнен по левому, 
либо по правому краю, не по верху или низу.*/ 

#obt_water {
   width: 100px;
   float: right;
}

/*  Элементы Рядом Друг с Другом

Если вы размещаете несколько обтекаемых элементов один за другим, 
они будут обтекаться один за другим, если достаточно места.
Например, в разметке печати, изображения могут быть установлены на страницу таким образом, 
чтобы текст обтекал их по мере необходимости. 
 */ 

#obt_water2 {
   float: left;
   width: 120px;
   margin-right: 10px;
}
#obt_water1 {
   width: 320px;   
   float: left;
}

/* Отмена действия свойства Float

Элементы, которые следуют за обтекаемым элементом будут протекать вокруг него. Чтобы избежать этого,
используйте свойство clear.
Свойство clear устанавливает, с какой стороны элемента запрещено его обтекание другими элементами.

В нижеуказанном примере, если мы установим свойство float на div, то только параграф, 
который следует после div будет обтекать изображение.
 */ 

#floating_my {
   float: right;
}

/* Использование свойства clear

Используйте значения right, left, и both для определения сторон элемента, 
где другие обтекаемые элементы не могут быть. 

Значением по умолчанию является none, что позволяет обтекание с двух сторон.  */ 



/* Отмена действия свойства Float

both используется для очистки обтекания со всех сторон. 
  */ 

#floating_my2 {
   float: right;
}
#clearing_my {    
   clear: both;
}

/* Свойство overflow

Как обсуждалось ранее, каждый элемент на странице является блоком. Если высота блока не установлена, 
то она будет расти, пока не будет способна вместить необходимый контент. 

Свойство overflow определяет поведение, которое возникает, 
когда содержимое элемента выходит за область элемента блока.    */ 

#overflow123 {
  width: 150px;
  height: 150px;
  background-color: LightBlue;
  float: left;
}


/*  Значения Свойства overflow

Существует четыре значения для свойства property: visible (значение по умолчанию),
scroll, hidden, и auto. 

Значение scroll всегда добавляет полосу прокрутки.
 */ 

#overflow234  {
   width: 150px;
   height: 150px;
   background-color: LightBlue;
   float: left;
   overflow: scroll;
}

/* auto и hidden

auto - Полосы прокрутки добавятся только при необходимости (если поток будет переполнен).
hidden - Отображается только область внутри элемента, остальное будет скрыто.


Значением по умолчанию для свойства overflow является visible.   */ 

#overflow345 {
   width: 150px;
   height: 150px;
   background-color: LightBlue;
   float: left;
   overflow: hidden;
}

/* Свойство z-index

Когда элементы расположены вне нормального потока, они могут накладываться на другие элементы.
Свойство z-index определяет порядок накладывания элементов (какой из элементов будет 
расположен впереди, или сзади по отношению к другим).


Красный квадрат перекрывает синий, потому что он был размещен позже в HTML разметке. 
Свойство z-index может изменить этот порядок. */ 


#blue_my123 { 
   background-color: #8EC4D0;
   margin-bottom: 15px;
   width: 120px;
   height: 120px;
   color: #FFF;
}
#red_my123 {
   background-color: #FF4D4D;
   position: relative;
   width: 120px;
   height: 120px;
   color: #FFF;
   margin-top: -50px;
   margin-left: 50px;
}



/*  Назначение свойства z-index

Присваивание высшего z-index значения к синему div и меньшего z-index значения к красному
div приведет к следующему результату:

Свойство z-index работает только с позиционированными элементами (position:absolute, 
position:relative, или position:fixed).
 */ 

#blue_my234 {
   background-color: #8EC4D0;
   margin-bottom: 15px;
   width: 120px;
   height: 120px;
   color: #FFF;
   z-index: 3; 
   position: relative;
}
#red_my234 {
   background-color: #FF4D4D;
   position: relative;
   width: 120px;
   height: 120px;
   color: #FFF;
   margin-top: -50px;
   margin-left: 50px;
   z-index: 2;
   position: relative;
}

/* CSS3

CSS3 это свежая версия стандарта CSS.
CSS3 полностью обратно совместим с более ранними версиями CSS.

Наиболее важными новыми особенностями являются:
Border radius(радиус рамки) - позволяет нам создавать закругленные углы для элементов.
Border images(рисованная рамка) - позволяет нам отображать рисованную рамку вокруг элемента.
Multiple backgrounds(множество фонов) - позволяет использовать множество фонов в элементе.
Анимации и эффекты, и многое другое! 

Есть еще много других великолепных свойств, которые мы рассмотрим в последующих уроках.  

CSS3: Новые Особенности

Чтобы сделать веб разработку проще и быстрее, CSS3 представляет дополнительные новые особенности,
включая следующие:

Box Shadow
Свойство box-shadow, вы можете добавлять одну, или несколько теней к элементу, определяя значения 
для цвета, размера, размытия и растяжения.

Градиенты 
Градиенты CSS3 позволяют вам установить цвет фона элемента на градиент. Доступно два типа градиентов: 
Linear(линейный) и Radial(радиальный).

CSS3: Новые Особенности

Трансформация(Transform) позволяет вам вращать, масштабировать, двигать, и смещать элементы. 

Другой известной особенностью являются Переходы(Transitions) которые позволяют вам создавать 
анимацию от одного значения свойства CSS к другому. Вы можете комбинировать их с трансформацией 
и анимировать позиционирование элементов, вращение и масштабирование.

Свойство, привлекающее больше всего внимания это Анимация(Animation). 
Анимация CSS имеет свои спецификации и позволяет вам создавать ключевые кадры(keyframes), 
устанавливать длительность, плавность, и другое.

Большинство новых особенностей уже было включено большинством веб браузеров,
так что вы можете насладиться мощностью CSS3.

*/ 


/* Вендорные Префиксы CSS

Вендорные префиксы CSS, или префиксы браузера CSS являются приставками используемыми 
производителями (вендорами) браузеров для экспериментальных, еще не принятых в стандарт,
CSS-свойств. Браузерные префиксы используются для добавления новых особенностей, 
которые могут не стать частью финальной и официальной спецификации CSS. 

Например, префиксом для Safari и Chrome является -webkit. Свойство border-radius в
настоящее время поддерживается в Chrome, Safari, и Mozilla, пока оно сопровождается
префиксом браузера.
Для определения border-radius в Chrome и Safari, используется следующий синтаксис: 


Префикс добавляется к свойству, чтобы оно работало в неподдерживаемых браузерах. 
Так что, возможно вы закончите с множественным определением одного и того же свойства,
каждого с префиксом браузера.

Хоть большинство браузеров сегодня работают без префиксов, важно знать это для обратной
совместимости и понимания старого кода.*/ 

#round {
    -webkit-border-radius: 24px;
    color: green;
    border-radius: 24px;
    border:1px solid green;
    width:200px;
    padding:25px;
}
/* Префиксы Браузера

Список вендорных префиксов для каждого браузера: 

Может быть скучной и раздражительной необходимость писать свойства от двух до пяти раз,
чтобы они работали во всех браузерах, но это временно. Браузеры улучшаются,
появляется поддержка стандартов основных версий свойств, и вы сможете удалить 
версии с префиксами.*/ 

#div8 {
   width: 50%;
   height: 50%;
}

/* Свойство border-radius

С помощью CSS3, вы можете дать любому элементу element "закругленные углы" используя
свойство border-radius .

  */ 

#div9 {
   width: 50%;
   height: 50%;
   border-radius: 20px;
   background-color: green;
   color: white;
   text-indent: 20px;
}


/* Специфические значения могут быть применены для свойства border-radius в следующем порядке:
верх-лево, верх-право, низ-право, низ-лево.  */ 

#div10 {
   width: 50%;
   height: 50%;
   border-radius: 0 0 20px 20px;
   background-color: green;
   color: white;
   text-indent: 20px;
}


/* Значения свойства border-radius могут быть также выражены в процентах.  */ 


/* Создание Окружности

Прямоугольник может быть превращен в окружность с помощью CSS. 
Чтобы создать окружность, радиус рамки должен быть равен половине высоты и ширины. 

Прямоугольник в нижеуказанном примере имеет ширину и высоту равные 200px. 
Установив радиус рамки равным 100px, углы будут округлены для формирования окружности:  */ 

#div11 {
   width: 150px;
   height: 150px;
   border-radius: 100px;
   background-color: green;
}


/* Свойство box-shadow

CSS3 свойство box-shadow применяет к элементам тень.
Компоненты свойства box-shadow декодируются браузерами в следующей манере:
- Первая длина для горизонтального смещения вызовет тень справа от блока (значение обязательно)
- Вторая длина для вертикального смещения вызовет тень под блоком (значение обязательно)
-  Цвет тени (значение опционально)

В примере ниже, горизонтальное и вертикальное смещение установлено на 10px:  */ 

#div12 {
   width: 300px;
   height: 100px;
   background-color: #9ACD32;
   box-shadow: 10px 10px #888888;
}

/*  Размытие и Растяжение

До установки цвета, находятся два также опциональных значения для элемента box-shadow, 
которыми являются blur(размытие) и spread(растяжение). 

Значения размытия и растяжения должны быть использованы до значения цвета.  */ 

#div13 {
    width: 300px;
    height: 100px;
    background-color: #9ACD32;
    box-shadow: 10px 10px 5px 5px #888888;
}

/* Отрицательные Значения

Отрицательные значения могут также использоваться со свойством box-shadow.

горизонтальное смещение - тень будет слева от блока
вертикальное смещение - тень будет над блоком
радиус размытия - отрицательное значение не допустимо
радиус растяжения - отрицательное значение вызовет сжатие тени
  */ 
#div14 {
    width: 300px;
    height: 100px;
    background-color: #9ACD32;
    box-shadow: 20px -20px 10px -5px #888888;
}

/* Создание Внутренней Тени

Ключевое слово "inset" позволяет рисовать внутреннюю тень в блоке.
Чтобы отобразить внутреннюю тень, просто добавьте ключевое слово inset: 

Вы можете одновременно создать inner(внутреннюю) и outer(внешнюю) тени,
разделяя каждую запятой.*/ 

#div15 {
    width: 300px;
    height: 100px;
    background-color: #9ACD32;
    box-shadow: inset 10px 10px 5px #888888;
}

/* Наслаивание Множества Теней

Вы можете определить столько теней для одного и того же блока, сколько вы хотите, 
записав их разделенными через запятую. 

В нижеуказанном примере, две внутренние тени созданы с помощью разделения их через запятую.   */ 

#div16 {
    width: 300px;
    height: 100px;
    background-color: #9ACD32;
    box-shadow: inset 10px 10px 5px #888888, inset -10px -10px 5px #888888;
}

/*  В случае, если мы указываем более одного значения, то, которое идет последним, 
будет размещено за другими тенями. 

Как и ожидалось, синяя тень (#B0E0E6) идет последней. */ 

#div17 {
    width: 300px;
    height: 100px;
    background-color: #9ACD32;
    box-shadow: 0 0 10px 4px #FF6347, 0 0 10px 30px #FFDAB9, 30px 0 20px 30px #B0E0E6;

    margin-left:30px;
    margin-top:30px;
}


/* Эффект Прозрачности

До CSS3, прозрачные фоновые изображения использовались для создания эффекта прозрачности.
Новые свойства CSS3 теперь позволяют создать эффект прозрачности намного легче.

CSS поддерживает названия цветов, шестнадцатеричные и RGB представления цвета.
В дополнение, CSS3 представляет следующее:

RGBA Цвета
Значения цвета RGBA являются расширением значений цвета RGB с альфа-каналом, 
который определяет прозрачность для цвета.
Значение цвета RGBA значит следующее: rgba(red(красный), green(зеленый), 
blue(голубой), alpha(альфа)). Параметром альфа является число, 
лежащее от 0.0 (полностью прозрачный) и до 1.0 (полностью непрозрачный).

HSL (Hue(Тон), Saturation(Насыщенность), Lightness(Светлота)) Цвета
Значение цвета HSL значит следующее: hsl(hue(тон), saturation(насыщенность), 
lightness(светлота)).
Тон это градус на цветовом колесе, варьирующийся от 0 до 360
0 (или 360) это красный, 120 это зеленый, 240 это синий.
Насыщенность это процентное значение: 100% значит полный цвет.
Светлота также является процентным значением; 0% это темный (черный) и 100% это белый. 
Цветовые значения HSLA являются расширением цветовых значений HSL с альфа-каналом - который
определяет прозрачность для цвета (также как и в RGBA).

В нижеуказанном примере, прозрачное стеклянное меню создно с помощью CSS3.

В HTML файле, добавлен тег <nav>, содержащий список <ul> с ссылками:  */ 



nav {
   padding: 70px 0;
   min-width: 500px; 
}
nav ul {
   background: linear-gradient(90deg, 
     rgba(255, 255, 255, 0) 0%, 
     rgba(255, 255, 255, 0.2) 25%, 
     rgba(255, 255, 255, 0.2) 75%, 
     rgba(255, 255, 255, 0) 100%);
   box-shadow: 0 0 25px rgba(0, 0, 0, 0.1),
     inset 0 0 1px rgba(255, 255, 255, 0.6);
}
nav ul li {
   display: inline-block;
}
nav ul li a {
   padding: 10px; 
   color: #FFFFFF;
   font-size: 18px;
   font-family: Arial;
   text-decoration: none;
   display: block;
 }
 
/* Тег <ul> стилизован с фоновым градиентом, который является белым и прозрачным. 
Добавлены два значения box-shadow, одно для внешней, темной тени; и одно для внутренних, 
светлых краев.

О некоторых из использованных свойств (типа фоновых градиентов) будет рассказано в следующих уроках.  */ 



/*  Свойство text-shadow

Свойство text-shadow определяет один и более эффектов тени, разделенных запятыми, 
которые будут применены к текстовому содержимому текущего элемента.

На изображении ниже изображено применение свойства text-shadow: 

- Значения offset-x и offset-y обязательны для использования свойства text-shadow.
- Значение color не является обязательным, но с тех пор, как значение по умолчанию 
стало прозрачным, то тень не появится, пока вы не укажете значение цвета.*/ 

#div18 {
   width: 70%;
   height: 70%;
}


/* Множество Теней Текста

Стиль свойства text-shadow может принимать множество значений в разделенном запятыми списке. 
В соответствии с CSS2, тени ложатся в порядке их появления, так что, если произойдет
их наложение, последняя определенная тень появится сверху. CSS3 изменил это, так что теперь 
тени применяются в обратном порядке.  */ 

#h1-123 {
    text-shadow: 5px 10px 2px #93968f, -3px 6px 5px #58d1e3;
}

/*  Этот пример определяет две тени текста в разных местах, с разным радиусом размытия и цветом.
Таким образом выглядит, будто у текста два источника света. 


Чтобы тень текста выглядела реалистично, запомните несколько следующих характеристик тени: 

- Тень, которая находится ближе к тексту, должна быть менее размыта, чем тень, которая 
находится дальше от текста. Тень, которая находится далеко от текста, обычно подразумевает
собой источник света, находящийся далеко от текста. 

- Тень, которая находится близко к тексту, обычно подразумевает собой, что поверхность 
под текстом находится близко, также как и источник света. Ближайшая к тексту тень является
более темной, чем дальняя, потому что меньше света может попасть между формой и поверхностью
под текстом. 

Чтобы убрать тень текста, установите свойство text-shadow на none; тени не будут
ассоциированы с этим элементом.
*/ 



/*  Работаем с Псевдоклассами

Псевдоклассы CSS позволяют нам стилизовать элементы, или части элементов, которые существуют
в дереве документа без использования JavaScript или других скриптов. Псевдоклассы начинаются 
с  ":" (двоеточия).
Наиболее часто используемыми псевдоклассами являются :first-child и :last-child. 

Псевдокласс :first-child находит любой элемент, являющийся первым в своем родителе. 
В следующем примере, селектор находит любой <p> элемент, который является первым дочерним 
div элементом:
 */ 

#parent444 p:first-child {
   color: green;
   text-decoration: underline;   
}

/* Псевдокласс :last-child находит любой элемент, являющийся последним в его родителе. 

В примере ниже, селектор находит любой <p> элемент, который является последним дочерним 
div элементом:  */ 

#parent555 p:last-child {
   color: green;
   text-decoration: underline;   
}

/*  Работаем с Псевдоэлементами

Псевдоэлементы используются для выбора специфических частей элемента.
Есть пять псевдоэлементов в CSS, каждый начинается с двойного двоеточия (::):

::first-line - первая строка текста селектора
::first-letter - первая буква текста в селекторе
::selection - выбирает часть текста, которая указана пользователем
::before - вставляет некоторое содержимое до элемента
::after - вставляет некоторое содержимое после элемента

В примере ниже, псевдоэлемент ::first-line используется для стилизации первой строки 
нашего текста: */ 

#first555::first-line {
   color: red;
}

/* Псевдоэлемент ::selection стилизует выбранный текст:  

Используется префикс -moz- , так как элемент ::selection еще не поддерживается 
браузером Mozilla.*/ 


#first567::selection {
    background: #8bc34a;
    color: #fff;
}


/* Работаем с Псевдоэлементами

Использование псевдоэлементов ::before и ::after позволяет нам добавлять широкое
разнообразие содержимого на страницу.

В примере ниже, псевдоэлемент ::before используется для добавления изображения до списка.

Если вы измените элемент ::before на ::after в примере выше, то изображения появятся 
в конце списка. 

p::before {
   content: url("https://html-css-js-evgeny-i-gurin.cs50.io/html-css-js/images/rypy_logo.gif");
   
}

 */
 
/*  Свойство word-wrap

Свойство word-wrap позволяет разбивать длинные слова и переносить их на следующую строку. 
Свойство имеет два значения: normal и break-word. 

В нижеуказанном примере свойство word-wrap имеет значение normal.
 */ 

#fir567 {
    width: 210px; 
    height: 100px;
    border: 1px solid #000000;
    word-wrap: normal;
}

/* Теперь давайте посмотрим, что случится с тем же примером, если мы установим значение 
break-word:  */ 

#fir123 {
   width: 210px; 
   height: 100px;
   border: 1px solid #000000;
   word-wrap: break-word;
}

/* Когда свойство word-wrap имеет значение break-word, браузер разбивает слово, 
если оно не помещается по ширине в заданную область. */ 



/* Правило @font-face

Правило @font-face позволяет загружать специфичные шрифты на веб-страницу. 
С помощью этого правила дизайнеры больше не лимитированы в установленных на 
пользовательских компьютерах шрифтах. 

В Internet Explorer 8 и более ранних версиях, URL должен указывать на файл 
Embedded(Внедряемый) OpenType (eot), в то время как Firefox, Chrome, и др. 
поддерживают шрифты True Type Fonts (ttf) и OpenType Fonts (otf).   */ 

#div19 {
   width: 70%;
   height: 70%;
}

/* Использование Правила @font-face

Каждая форма семейства шрифтов должна быть объявлена с помощью правила @font-face.
В примере ниже, загружен пользовательский шрифт "Delicious" и используется в заголовке.

@font-face {
  font-family: Delicious; 
  src: url('Delicious-Roman.otf'); 
} 
@font-face { 
  font-family: Delicious; 
  font-weight: bold; 
  src: url('Delicious-Bold.otf'); 
}
h1{
   font-family: Delicious, sans-serif; 
}  */ 


/* 
Браузер Internet Explorer имеет встроенный баг при определении множества правил @font-face. 
Использование #iefix исправляет данную проблему, что показано в примере ниже: 

@font-face { 
   font-family: Delicious; 
   src: url('Delicious-Roman.ttf');
   src: url('Delicious-Roman.eot?#iefix'); 
}

Вопросительный знак заставляет браузер IE думать, что оставшаяся часть строки является 
строкой запроса, загружающая только файл EOT. Остальные браузеры руководствуются спецификацией
и выбирают необходимый формат, основываясь на каскаде src.*/ 



/* Создание Линейного Градиента

Градиенты в CSS3 позволяют отображать плавные переходы между двумя и более цветами. В CSS3 
определены два типа градиентов: Linear(Линейный) и Radial(Радиальный). 

Чтобы создать линейный градиент, вам необходимо определить по меньшей мере две цветные остановки. 
Цветные остановки это цвета, между которыми вы хотите воспроизвести плавные переходы. 
Вы также можете установить точку старта и направление - или угол - вместе с эффектом градиента.
В примере ниже, синий и черный цвета используются для создания линейного градиента 
сверху вниз.  

Этот синтаксис работает в Mozilla (-moz). Если вы работаете с другим браузером, 
добавьте соответствующий префикс, чтобы браузер понимал градиент.

Вы можете использовать названия цветов, шестнадцатеричные значения, 
RGB, или HSL чтобы определить градиент цвета.*/ 

#div20 {
   float: left;
   width: 300px; 
   height: 100px;
   margin: 4px;
   color: #FFF;  
   background:-moz-linear-gradient(DeepSkyBlue, Black);
}

/* Свойство background-size

Свойство background-size добавляет новую функциональность для CSS, которая позволяет 
нам указать размер фоновых изображений, используя либо длину, либо проценты. 
 
Текущие версии большинства популярных браузеров - включая Firefox, Safari, 
Chrome, Internet Explorer, и Opera - теперь поддерживают свойство background-size, 
без необходимости использования вендорных префиксов.

Текущие версии большинства популярных браузеров - включая Firefox, Safari, Chrome, 
Internet Explorer, и Opera - теперь поддерживают свойство background-size, 
без необходимости использования вендорных префиксов.*/ 

#div21 {
   height: 150px;
   width: 200px;
   border: 1px solid #179;
   background: url("https://html-css-js-evgeny-i-gurin.cs50.io/html-css-js/images/rypy_logo.gif") no-repeat 50% 50%;
   background-size: 170px 170px;
}

/* Значения Свойства background-size

Двумя другими возможными значениями для размера фона являются ключевые слова contain и cover. 

Ключевое слово contain масштабирует изображение, чтобы оно соответствовало контейнеру. 
Другими словами, изображение будет расти, или уменьшаться пропорционально, 
но ширина и высота не будут превышать размеров контейнера:
 */ 
 
#div22 {
   height: 150px;
   width: 200px;
   border: 1px solid #179;
   background: url("https://html-css-js-evgeny-i-gurin.cs50.io/html-css-js/images/rypy_logo.gif") no-repeat 50% 50%;
   background-size: contain;
}


/* Свойство background-size также поддерживает ключевое слово cover. 
Изображение масштабируется, чтобы заполнить весь контейнер; однако,
если установлено иное соотнощение сторон, то изображение будет обрезано:
  */ 

#div23 {
   height: 150px;
   width: 200px;
   border: 1px solid #179;
   background: url("https://html-css-js-evgeny-i-gurin.cs50.io/html-css-js/images/rypy_logo.gif") no-repeat 50% 50%;
   background-size: cover;
}


/* Свойство background-clip

Свойство background-clip определяет область изображения фона.

Свойство принимает три различных значения:

border-box - (по умолчанию) фон выводится под границами
padding-box - фон отображается внутри границ
content-box - фон отображается только внутри контента

В примере ниже, первый элемент div со свойством background-clip 
установлено значение padding-box; во втором элементе div установлено 
значение content-box.  */ 

#firs123t {
   border: 2px dotted black;
   padding: 20px;
   background: LightBlue;
   background-clip: padding-box;
}
#second123 {
   border: 2px dotted black;
   padding: 20px;
   background: LightBlue;
   background-clip: content-box;
}

/* Свойство background-clip с Изображениями
 */ 

#div24 {
   background-image: url("https://html-css-js-evgeny-i-gurin.cs50.io/html-css-js/images/rypy_logo.gif");
   background-clip: content-box;
}

/* Прозрачные Рамки со свойством background-clip

Установка прозрачной рамки элемента создаст свой собственный фон элемента под рамкой. 
В нижеуказанном примере мы сделали рамки прозрачными, используя RGBA, 
но в действительности они стали чисто серыми.  

#div25 {
    border: 20px solid rgba(0, 0, 0, 0.3);
    width:200px;
    position:absolute;
    top:50px;
    left:50px;
    background-color:white;
}

*/ 

/* Установив значение свойства background-clip на padding-box, рамки станут прозрачными.

Эффект прозрачности достигается с background-clip:padding-box. 
Без него, фон блока проходит под рамками, что делает его непрозрачным.  

#div26 {
    border: 20px solid rgba(0, 0, 0, 0.3);
    -webkit-background-clip: padding-box; 
    background-clip: padding-box; 
    width:200px;
    position:absolute;
    top:50px;
    left:50px;
    background-color:white;
}

 */
 
/* Множество Фоновых Изображений

Способность иметь несколько фоновых изображений является новой особенностью CSS3.
Множество фоновых изображений определяется с помощью разделенного запятыми списка 
значений для свойства background-image. Первое изображение появится вверху, последнее внизу. 

В примере ниже, у нас есть два фоновых изображения: первое это CSS лого
(выравненное по нижнему и правому краям); второе это изображение с кодом 
(выравненное к левому верхнему углу). 

div {
  width: 400px;
  height: 300px;
  background-image: url(csslogo.png), url(csscode.jpg);
  background-position: right bottom, left top;
  background-repeat: no-repeat;
} 


 */ 



/* Множество Фоновых Изображений

Положение фоновых изображений может быть изменено с помощью свойства background-position. 
Например: 

div {
   width: 400px;
   height: 300px;
   background-image: url(csslogo.png), url(csscode.jpg);
   background-position: right top, left top;
   background-repeat: no-repeat;
} 


Множество фоновых изображений может быть определено с помощью свойства background:.

background: url(csslogo.png) right top no-repeat, 
url(csscode.jpg) left top no-repeat; 
*/ 



/*  Свойство opacity

CSS свойство opacity добавляет прозрачность к любому элементу.
В примере ниже, мы установили различные уровни прозрачности одному 
и тому же изображению, так что вы можете увидеть разницу.  

#img1 {
   opacity: 1;
}
#img2 {
   opacity: 0.5;
}
#img3 {
   opacity: 0.25;
}

Значением свойства opacity должно быть число между 0.0 (полностью прозрачный) 
и 1.0 (полностью непрозрачный).

Свойство Opacity в браузере Internet Explorer

Чтобы свойство opacity работало во всех версиях браузера IE, используйте 
filter:alpha(opacity=x) вместе со свойством opacity. x может принимать значения от 0 до 100.
Значение 0 приводит к результату полностью прозрачного элемента 
(например, 100% прозрачности), а значение 100 делает элемент полностью непрозрачным 
(т.е., 0% прозрачности).

Например, чтобы код работал с браузером IE, если значение свойства opacity 
изображения установлено на 0.5, то код должен выглядеть следующим образом: 

#img {
  opacity: 0.5;
  filter: alpha(opacity=50);
}
*/ 


/* Переходы CSS3

Переходы CSS3 позволяют нам изменять одно значение свойства на другое в течениe 
заданной продолжительности. 
transition-property - указывает свойство, к которому будет применен переход
transition-duration - определяет продолжительность, в течение которой произойдет переход
transition-timing-function - определяет, как будет изменяться темп перехода во время 
его продолжительности
transition-delay - определяет задержку (в секундах) для эффекта перехода

В примере ниже, мы установили свойство перехода на transform, 
с продолжительностью равной 5 секундам, с функцией ease-in которая устанавливает 
эффект перехода с медленным стартом.  

transition: transform 5s ease-in;


Эффект перехода может быть применен к широкому множеству свойств CSS, 
включая background-color, width, height, opacity, и многие другие.
*/ 



#div25 {
   width: 50px;
   height: 50px;
   background: #32CD32;
   transition: width 3s;
}
#div25:hover {
   width: 250px;
}


/*  transition-timing-function

Свойство transition-timing-function определяет насколько быстро должно изменяться 
значение стилевого свойства, для которого применяется эффект перехода.
Может принимать следующие значение:
ease - анимация начинается медленно, затем быстро ускоряется.
ease-in - начинается медленно, затем ускоряется и останавливается резко.
ease-out - начинается быстро, но замедляется до остановки.
ease-in-out - похоже на ease, но с более тонким ускорением и замедлением.
linear - постоянная скорость прохождения анимации; часто применяется для изменений
цвета и прозрачности.

Наконец, у нас есть cubic-bezier(), что позволяет нам определять ваши собственные
значения в функции cubic-bezier. Возможными значениями являются числа от 0 до 1. */ 

#div26 {
    width: 50px;
    height: 50px;
    background: #32CD32;
    transition: width 3s;
    transition-timing-function: cubic-bezier(0,0,1,1);
    -webkit-transition: width 3s;
    -webkit-transition-timing-function: cubic-bezier(0,0,1,1);
}
#div26:hover {
    width: 250px;
}

/*  CSS3 Трансформация

Трансформация в CSS3 позволяет вам транслировать, вращать, масштабировать и искажать элементы.
Трансформация это эффект, который позволяет вам изменять размер, форму и положение элемента
на веб-странице.
CSS3 поддерживает 2D и 3D трансформации. Давайте взглянем на вращающуюся трансформацию:  */ 

#div27 {
   width: 200px;
   height: 100px;
   margin-top: 30px;
   background-color: #32CD32;
}


/* 
Теперь, давайте применим вращение к элементу div на 10deg: */ 

#div28 {
   width: 200px;
   height: 100px;
   margin-top: 30px;
   background-color: #32CD32;
   transform: rotate(10deg);
}



/*  Метод rotate() вращает элемент по, или против часовой стрелки,
в соответствии с заданным градусом.
Отрицательные значения приведут к вращению против часовой стрелки.*/ 



/*  Использование Отрицательных Значений

Как было сказано ранее, использование положительных значений 
будет вращать элемент по часовой стрелке, а использование отрицательных 
значений будет вращать элемент против часовой стрелки. 

div.positive {
   width: 200px;
   height: 100px;
   margin-top: 30px;
   background-color: #32CD32;
   transform: rotate(10deg);
}
div.negative {
   width: 200px;
   height: 100px;
   margin-top: 30px;
   background-color: #32CD32;
   transform: rotate(-10deg);
}

*/ 


/* transform-origin

Свойство transform-origin позволяет вам изменять позицию трансформируемого элемента. 
Значением по умолчанию является 50% 50%, что соответствует центру элемента.
В примере ниже, мы использовали свойство transform-origin вместе с transform-rotate. 
Начало оси-x (горизонтали) установлено на 25% от левого края. Начало оси-y (вертикали) 
установлено на 75% от верхнего края.

0 0 является таким же значением, как и top left, а 100% 100% это то же самое, что и bottom right.
Свойство transform-origin должно использоваться вместе со свойством transform. */ 

#empty-div {
   position: relative;
   height: 100px;
   width: 100px;
   margin: 30px;
   padding: 10px;
   border: 1px solid black;
}
#green-div {
   padding: 50px;
   position: absolute;
   background-color: #8bc34a;
   border: 1px solid white;
   transform: rotate(15deg);
   transform-origin: 25% 75%;
}

/* Метод translate()

Метод translate() двигает элемент с его текущей позиции (в соответствии
с заданными параметрами по оси x и оси y). Положительные значения сдвигают
элемент вниз и вправо от его положения по умолчанию, в то время как отрицательные
значения сдвигают элемент вверх и влево от положения по умолчанию.

В примере ниже, элемент div сдвигается на 100px вправо и 50px вниз:   */ 

#div29 {
   padding: 50px;
   position: absolute;
   background-color: #32CD32;
   transform:translate(100px, 50px);
}

/*  Метод skew()

Метод skew() наклоняет элемент вдоль оси-x и оси-y на заданный угол.

Следующий пример наклоняет элемент <div> на 30 градусов вдоль оси-x:  

transform: skew(30deg);


*/ 


/* Метод scale()

Метод scale() увеличивает или уменьшает размер элемента, 
в соответствии с заданными параметрами ширины и высоты. 
1 соответствует оригинальному размеру, 2 соответствует удвоенному оригинальному 
размеру и так далее. 

В примере ниже, мы уменьшили первый элемент div умножив на коэффициент
0.7 по горизонтали и вертикали, и увеличили второй элемент div умножив 
на коэффициент 1.5 по горизонтали и вертикали.

Если был передан только один параметр методу scale(), то он применит 
этот коэффициент и к высоте и к ширине.*/ 

#first567 {
   width: 200px;
   height: 100px;
   background-color: #8BC34A;
   transform: scale(0.7, 0.7);
   color:white;
}
#second567 {
   margin: 60px;
   width: 200px;
   height: 100px;
   background-color: #8bc34a;
   transform: scale(1.5,1.5);
   color:white;
}





/*  Множество Трансформаций

Несколько трансформаций могут быть выполнены одновременно. 
Вращение и масштабирование элемента одновременно является примером этому.
Применить множество трасформаций к одному элементу очень просто; 
просто разделите их с помощью пробелов.

Если вы используете запятые для разделения функций, 
то ни одна из функций не будет применена, 
так что не забывайте, что использовать запятые нельзя.

Пример использования двух трансформаций: */ 

#div30{
    width: 200px;
    height: 100px;
    background-color: #8BC34A;
    transform: rotate(45deg) translate(100px);
    -webkit-transform: rotate(45deg) translate(100px);
    color:white;
}

/* Анимация CSS3

Анимация позволяет элементу постепенно измениться с одного стиля к другому.
Вы можете изменять множество CSS свойств столько раз, сколько вы хотите.
Ключевые кадры содержат стили, которые будут иметь элементы в определенное время

Правило @keyframes

При определении стилей CSS внутри правила @keyframes, анимация постепенно изменится 
от текущего стиля к новому стилю в определенное время.
Чтобы получить работающую анимацию, вам необходимо связать анимацию с элементом.

Следующий пример изменит фоновый цвет элемента три раза: когда анимация выполнена
на 50%, на 70%, и когда анимация будет выполнена на 100%.

example это название анимации. Вы можете использовать любое имя для вашей анимации.


@keyframes example {
   0%  {background-color: red;}
   50%  {background-color: yellow;}
   70%  {background-color: blue;}
   100% {background-color: green;}
}*/ 




/* Правило @keyframes

В качестве альтернативы использования процентов, вы можете использовать ключевые 
слова from и to , где:
from это значение начинающееся с 0%
to это значение заканчивающееся на 100%.

Два примера ниже являются эквивалентными, и выводят один и тот же результат:  

@keyframes colorchange {
   0% {background-color: red;}
   100% {background-color: green;}
}

@keyframes colorchange {
   from {background-color: red;}
   to {background-color: green;}
}


*/ 



/*  Правило @keyframes

Чтобы анимация работала, вам необходимо связать анимацию с элементом.
В примере ниже, анимация длится одну секунду и изменяет красный фоновый 
цвет элемента div на зеленый и голубой.  */ 

#div31 {
   width: 100px;
   height: 100px;
   background-color: red;
   animation-name: colorchange;
   animation-duration: 9s;
}
@keyframes colorchange {
   0% {background-color: red;}
   16% {background-color: orange;}
   32% {background-color: yellow;}
   48% {background-color: green;}
   62% {background-color: blue;}
   76% {background-color: blue;}
   100% {background-color: purple;}
} 


/* Свойство animation-name определяет используемую для элемента анимацию.
Свойство animation-duration определяет длительность выбранной анимации. 

Если свойство animation-duration не было определено, то анимация не будет
воспроизведена, потому что значением по умолчанию длительности является 0.  */ 


/* Свойство animation-name

Свойство animation-name определяет какую анимацию использовать. 
В этом примере имя анимации установлено на colorchange, что соответствует
определенным ключевым кадрам.

 */ 
 
#div32 {
    animation-name: colorrypy;   
    animation-duration: 5s;
    height:100px;
    background-color:red;
    -webkit-animation-duration: 5s;
    -webkit-animation-name: colorrypy; 
}
@keyframes colorrypy {
    from { width: 0px; }
    to { width: 100px; }
}
@-webkit-keyframes colorrypy {
    from { width: 0px; }
    to { width: 100px; }
}


/* 
Свойство animation-duration определяет длительность выбранных анимаций в секундах.

Если имя анимации не соответствует ни одному правилу ключевых кадров, 
то анимация не будет воспроизведена.  */ 



/*  Свойства Анимации

animation-timing-function определяет кривую скорости анимации. 
Может иметь следующие значения:
ease - анимация начинается медленно, затем быстро, 
затем медленно заканчивается (по умолчанию)
linear - анимация с одинаковой скоростью от начала и до конца
ease-in - анимация с медленным началом
ease-out - анимация с медленным концом
ease-in-out - анимация с медленным началом и концом
cubic-bezier(n,n,n,n) - позволяет вам определять собственные значения в 
функции cubic-bezier


animation-delay - определяет задержку до начала анимации. 
CSS синтаксис выглядит следующим образом:

animation-delay: 2s;

Значения animation-delay и animation-duration могут быть 
определены в секундах (s) или миллисекундах (ms).*/ 

#div33 {
    animation-name: colorchange1; 
    animation-duration: 5s;
    animation-timing-function: linear;
    height:100px;
    width:0px;
    background-color:red;
    -webkit-animation-name: colorchange1; 
    -webkit-animation-duration: 5s;
    -webkit-animation-timing-function: linear;
}
@keyframes colorchange1 {
    from { width: 0px; }
    to { width: 100px; }
}
@-webkit-keyframes colorchange1 {
    from { width: 0px; }
    to { width: 100px; }
}


#div34 {
    animation-name: colorchange2;
    animation-duration: 5s;
    animation-delay: 2s;
    height:100px;
    width:0px;
    background-color:red;
    -webkit-animation-name: colorchange2;
    -webkit-animation-duration: 5s;
    -webkit-animation-delay: 2s;
}
@keyframes colorchange2 {
    from { width: 0px; }
    to { width: 100px; } 
}
@-webkit-keyframes colorchange2 {
    from { width: 0px; }
    to { width: 100px; }
}


/* Еще Больше Свойств Анимации

Свойство animation-iteration-count определяет количество повторов анимации. 
Например, вы можете установить, чтобы анимация выполнилась 5 раз: */ 

#div35 {
    animation-name: colorchange3;    
    animation-duration: 5s; 
    animation-delay: 2s;
    animation-iteration-count: 5;
    height:100px;
    width:0px;
    background-color:red;
    -webkit-animation-name: colorchange3;    
    -webkit-animation-duration: 5s; 
    -webkit-animation-delay: 2s;
    -webkit-animation-iteration-count: 5;
}
@keyframes colorchange3 {
    from { width: 0px; }
    to { width: 100px; }
}
@-webkit-keyframes colorchange3 {
    from { width: 0px; }
    to { width: 100px; }
}



/* 
Чтобы анимация повторялась бесконечно, просто используйте значение infinite: */


#div36 {
    animation-name: colorchange4;   
    animation-duration: 5s; 
    animation-delay: 2s;  
    animation-iteration-count: infinite;
    height:100px;
    width:0px;
    background-color:red;
    -webkit-animation-name: colorchange4;   
    -webkit-animation-duration: 5s; 
    -webkit-animation-delay: 2s;  
    -webkit-animation-iteration-count: infinite;
}
@keyframes colorchange4 {
    from { width: 0px; }
    to { width: 100px; }
}
@-webkit-keyframes colorchange4 {
    from { width: 0px; }
    to { width: 100px; }
}




/* 
animation-direction указывает, как ключевой кадр должен быть применен.
Значениями могут быть:
normal - значение по умолчанию, что значит, что оно выполняется от 0 % до 100%. 
reverse - анимация выполняется в обратном направлении от 100 % до 0%
alternate - анимация выполняется вперед, затем обратно, затем снова вперед.
alternate reverse - анимация сначала выполняется в обратном направлении, затем вперед
, затем снова в обратном направлении.


Если вы используете 0 или отрицательное число для animation-iteration-count, 
то анимация никогда не начнется.
  */ 



/* Свойство animation

Обратите внимание на следующий пример:  */ 

#div37 {
    animation-name: colorchange5;
    animation-duration: 3s;
    animation-timing-function: ease-in;
    animation-delay: 1s;
    animation-iteration-count: infinite;
    animation-direction: reverse;
    height:100px;
    width:0px;
    background-color:red;
    -webkit-animation-name: colorchange5;
    -webkit-animation-duration: 3s;
    -webkit-animation-timing-function: ease-in;
    -webkit-animation-delay: 1s;
    -webkit-animation-iteration-count: infinite;
    -webkit-animation-direction: reverse;
}
@keyframes colorchange5 {
    from { width: 0px; }
    to { width: 100px; }
}
@-webkit-keyframes colorchange5 {
    from { width: 0px; }
    to { width: 100px; }
}


/*Одно свойство animation может быть использовано 
для достижения такого же результата, как в вышеуказанном коде:  */ 

#div38 {
    animation: colorchange6 3s ease-in 1s infinite reverse;
    -webkit-animation: colorchange6 3s ease-in 1s infinite reverse;
    height:100px;
    background-color:red;
    width:0px;
}
@keyframes colorchange6 {
    from { width: 0px; }
    to { width: 100px; }
}
@-webkit-keyframes colorchange6 {
    from { width: 0px; }
    to { width: 100px; }
}

/* Порядок, в котором объявляется каждое свойство в сокращенной версии, 
не может быть изменен, иначе анимация не будет работать правильно.  */ 



/*  3D Трансформация

Вместе с осями x и y, 3D Трансформация представляет ось-Z, которая позволяет 
3D манипуляции.
3D Трансформация похожа на 2D Трансформацию:
rotateX(), rotateY() и rotateZ() вращают элемент в 3-х мерном пространстве 
вокруг соответствующих осей и с заданным градусом.

Вы можете выключить все трансформации, примененные к элементу, 
используя функцию none: transform: none;
 */ 

#X {
    width:250px;
    height:100px;
    color:white;
    background-color:green;
    transform: rotateX(150deg);
    -webkit-transform: rotateX(150deg);
}
#Y {
    width:250px;
    height:100px;
    color:white;
    background-color:green;
    transform: rotateY(150deg);
    -webkit-transform: rotateY(150deg);
}
#Z {
    width:250px;
    height:100px;
    color:white;
    background-color:green;
    transform: rotateZ(150deg);
    -webkit-transform: rotateZ(150deg);
}


/* Сдвиг

Методы 3D сдвига позволяют вам передвигать элементы горизонтально 
(translateX), вертикально (translateY) и к или от экрана (translateZ), 
используя любые единицы длины (px, em, %, и т.д.). Положительные значения 
сдвигают элемент к зрителю, а отрицательные – от него.

#mybox1 {
   transform: translateX(29px) 
     translateY(5em) 
     translateZ(-13px);
}

Метод translate3d() позволяет вам передавать значения x, y, и z, все за один раз,
следующим образом: */ 

#mybox1 {
    transform: translate3d(-20px, 4em, 10px);
    -webkit-transform: translate3d(-20px, 4em, 10px);
    width:250px;
    height:100px;
    color:white;
    background-color:green;
}

/*
Также, как и в методе translate3d(), существуют также scale3d() 
и rotate3d(), которые применяются для масштабирования и вращения элементов в 3D.
 
 
Сдвиг элемента похож на косвенное позиционирование - он не влияет на поток документа.
Сдвинутый элемент оставит свое положение в потоке и появится только для перемещения.  
*/ 



/*  Перспектива

Перспектива определяет глубину воспроизведения 3D сцены. Представляйте себе перспективу, 
как расстояние от зрителя до объекта. Чем больше значение, тем больше расстояние
и меньше интенсивность визуального эффекта. 
При определении свойства perspective для элемента, перспективный вид получают именно
дочерние элементы, а не сам элемент.
 */ 

#empty-div {
    position: relative;
    height: 200px;
    width: 200px;
    margin: 30px;
    padding: 10px;
    border: 1px solid black;
    perspective: 100px;
    -webkit-perspective: 100px;
}
#green-div {
    padding: 60px;
    position: absolute;
    background-color: #8bc34a;
    border: 1px solid white;
    transform: rotateX(45deg);
    -webkit-transform: rotateX(45deg);
}

/*  Свойство perspective влияет только на трансформированные 3D элементы.*/ 

