<!DOCTYPE html> 
<html lang="en"> <!-- lang это вставки на других языках, которые могут различаться по своим правилам оформления, например кавычки -->
    <head>
        <meta charset="utf-8">  <!-- капитан очивидность говорит, что это utf-8 --> 
        <!--  
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="description" content="">
        <meta name="author" content="">
         -->  <!-- настройки для экранов c разным расширением и описания автора -->

        <title>title</title>   <!--  заголовк страницы в браузере --> 

        <link rel="icon" href="https://html-css-js-evgeny-i-gurin.cs50.io/html-css-js/images/rypy_logo.gif" type="gif">   <!-- значек заголовка страницы в браузере --> 

        <!-- <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css"> --> <!-- ссылка на bootstrap 4 --> 
        
        <!-- <link href="https://fonts.googleapis.com/css?family=Handlee" rel="stylesheet"> --> <!-- ссылка на шрифты, не использовать с bootstrap --> 
        
        <link href="main.css" rel="stylesheet">  <!-- ссылка на css -->  
        
        <!--[if lt IE 9]>
          <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
          <script src="https://oss.maxcdn.com/libs/respond.js/1.3.0/respond.min.js"></script>
        <![endif]-->         <!-- теги скриптов -->  
        
        <script>  
        function allowDrop(ev) {
                ev.preventDefault();
        }

        function drag(ev) {
                ev.dataTransfer.setData("text", ev.target.id);
        }

        function drop(ev) {
                ev.preventDefault();
        var data = ev.dataTransfer.getData("text");
                ev.target.appendChild(document.getElementById(data));
        }
        </script> <!-- скрипт для перетаскивания--> 

    </head>
    
    <body>
         
        текст.    
            
        <p>параграф текста.</p>
        
        <hr />  <!--  горизонтальная линия     --> 
        
        <p>Здесь <br/> перенос строки.</p>  <!--  br/ это перенос строки     --> 
        
        <p>Обычный текст</p>
        
        <p><b>Текст жирным шрифтом</b></p>
        
        <p><big>Текст крупным шрифтом</big></p>
        
        <p><i>Текст курсивом</i></p>
        
        <p><small>Текст мелким шрифтом</small></p>
        
        <p><strong>Важный текст</strong></p>
        
        <p><sub>Подстрочный текст</sub></p>
        
        <p><sup>Надстрочный текст</sup></p>
        
        <p><ins>Вставленный текст</ins></p>
        
        <p><del>Удаленный текст</del></p>
        
        </br></br> 
        
        <h1>Заголовок 1</h1>
        <h2>Заголовок 2</h2>
        <h3>Заголовок 3</h3>
        <h4>Заголовок 4</h4>
        <h5>Заголовок 5</h5>
        <h6>Заголовок 6</h6>
        
        </br></br>
        
        <p class="quote">class="name" - так обозначается class</p>
        
        </br></br>
        
        <p align="center">Этот текст выровнен по центру</p> <!-- Атрибуты всегда пишутся в открывающем теге и имеют следующую парную структуру: name="value". -->
        
        </br></br>
        
        <p>горизонтальная линия 150 пикселей <hr width="150px" /></p> <!-- ширина линии -->
        
        <p>горизонтальная линия 50%  экрана <hr width="50%" /></p> <!-- ширина линии -->
        
        </br></br>
        
        <p align="center">Линия выравнена по правому краю<br />
        <hr width="35%" align="right" />А страка по левому
        
        </br></br>
        
        <img src="https://d1u1mce87gyfbn.cloudfront.net/hero/brigitte/full-portrait.png" alt="Атрибут alt обязателен" />  <!-- синтаксис для добавления изображения -->
        
        </br></br> 
        
        <img src="https://d1u1mce87gyfbn.cloudfront.net/hero/brigitte/full-portrait.png" height="150px" width="50px" alt="" /> <!-- размер изображения высота и ширина в пиксулях-->
        
        </br></br>
        
        <img src="https://d1u1mce87gyfbn.cloudfront.net/hero/brigitte/full-portrait.png" height="2%" width="2%" alt="" /> <!-- размер изображения высота и ширина в процентах-->
        
        </br></br>
        
        <img src="https://d1u1mce87gyfbn.cloudfront.net/hero/brigitte/full-portrait.png" 
                                        height="8%" width="8%" border="3px" alt="" />  <!-- изображения в рамке-->
        
        </br></br>
        
        <a href="https://playoverwatch.com/en-us/">овавоч</a>
        
        </br></br>
        
        <a href="https://playoverwatch.com/en-us/" target="_blank">овавоч окроеться в новом окне</a>
        
        </br></br>
        
        пример нумерованного списка:
        <ol>
                <li>Красный</li>
                <li>Синий</li>
                <li>Зеленый</li>
        </ol>
        
        </br></br> 
        
        ненумерованный список:
        <ul>
                <li>Красный</li>
                <li>Синий</li>
                <li>Зеленый</li>
        </ul> 

        
        </br></br>
        
        <p>пример таблицы:</p>
        
        <table border="1">
           <tr>
              <td>Красный</td>
              <td>Синий</td>
              <td>Зеленый</td>
           </tr>
           <tr>
              <td>Желтый</td>
              <td colspan="2">Оранжевый</td>
           </tr>
           <tr>
              <td colspan="3" align="center">Фиолетовый</td>
           </tr>
           <tr>
              <td colspan="3" align="right">Белый</td>
           </tr>
        </table>
        <br>
        
        </br></br>
        
        <p>пример таблицы c цветными ячейками:</p>
        
        <table border="3">
           <tr>
              <td bgcolor="red">Красный</td>
              <td bgcolor="blue">Синий</td>
              <td bgcolor="green">Зеленый</td>
           </tr>
           <tr>
              <td bgcolor="yellow">Желтый</td>
              <td colspan="2" bgcolor="orange">Оранжевый</td>
           </tr>
           
        </table>
        
        </br></br>
        
        <!-- HTML большинство элементов - это так называемые блочные или строчные элементы.
        Блочные элементы начинаются с новой строки.
        Например: <h1>, <form>, <li>, <ol>, <ul>, <p>, <pre>, <table>, <div>, итд.

        Строчные элементы обычно пишутся без переноса строки. 
        Например: <b>,  <a>, <strong>, <img>, <input>, <em>, <span>, итд.

        Элемент <div> - блочный элемент, часто используемый как контейнер для других элементов HTML.
        При использовании с CSS, элемент "<div> может задавать стиль блокам контента: -->
        
        <h1>Заголовок</h1>
                <div style="background-color:grey; color:white; padding:10px;">
                        <p>Это параграф вашего контента.</p>
                </div>                
                        
        <!-- Остальные элементы могут быть использованы либо как блочные, либо как строчные элементы. Это такие элементы, как: 
        APPLET - встроенное Java-приложение
        IFRAME - встроенный фрейм
        INS - вставленный текст
        MAP - изображение-карта
        OBJECT - встроенный объект
        SCRIPT - встроенные в HTML-документ сценарии

        Можно вставить строчные элементы внутри блочных элементов. Например, вы можете иметь несколько элементов <span> внутри одного <div> элемента. -->

        
        </br></br>
        
        <!-- Элемент <span> - строчный элемент, часто используемый как контейнер для текста.
        При использовании с CSS элемент <span> может задавать стиль отдельных частей текста: -->
        
        
          <h2>Некоторое <span style="color:red">важное</span> сообщение</h2>

        </br></br>
        
        <!-- Атрибут action указывает на веб-страницу, которая должна загрузиться после отправки формы пользователем.
        
        <form action="https://playoverwatch.com/en-us/"> </form>
        
        Когда используется метод GET, в URL-адресе веб-страницы будут отображаться данные формы.
        
        Атрибут method указывает на метод HTTP - запроса (GET или POST), который будет использоваться при отправке формы (см. описание ниже):
        
        <form action="url" method="GET">
        
        <form action="url" method="POST">
        
        Когда используется метод GET, в URL-адресе веб-страницы будут отображаться данные формы.


        Метод POST используется, когда требуется обновить данные в форме или когда в форме содержится конфиденциальная информация (пароли). 
        Метод POST безопасней, потому что передаваемые данные не видны пользователю в URL-адресе страницы. 
        
        В атрибуте name указывается название формы. 

        Для того, чтобы получить данные пользователя, нужны соответствующие элементы формы, такие как текстовые поля. Элемент <input> имеет 
        множество вариаций, что определяется атрибутом type. Например: text, password, radio, URL, submit и другие. -->

        
        <!-- В приведённом ниже примере показана форма с просьбой ввести имя пользователя и пароль:-->
        
        <form>
                <input type="text" name="имя пользователя" /><br />
                <input type="password" name="пароль" />
        </form>
         
        </br></br>
         
        <!-- Если мы изменим тип ввода данных на radio, пользователь сможет выбрать только один вариант из представленного списка:--> 
                
        <input type="radio" name="gender" value="male" />Мужской <br />
        <input type="radio" name="gender" value="female" />Женский <br />      
        
        </br></br>
        <!-- Если установлен тип checkbox, у пользователя будет возможность выбрать несколько вариантов: -->
        
        <input type="checkbox" name="gender" value="1" />Мужской <br />
        <input type="checkbox" name="gender" value="2" />Женский <br />
        
        </br></br>
        
        <!-- При нажатии кнопки отправки, форма отправляется атрибуту action:   -->
        
        <input type="submit" value="Отправить" />
        
        </br></br>
        
        <!--Далее, мы создадим Форму Обратной Связи. Форма будет включать поля Name (Имя), Email, и Message (Сообщение). Мы также добавим кнопку Submit. -->
        
        <form>
          <input name="name" type="text" /><br/>
          <p></p>
          <input name="email" type="email" /><br/>
          <p></p>
          <textarea name="message"></textarea><br/>
          <input type="submit" value="отправить" class="submit" />
        </form>
        
        
        </br></br>
        
        <!--  цвет фона
        Атрибут bgcolor используется для изменения цвета фона веб-страницы. 
         <body bgcolor="#000099">             -->
        
        <h1>
         <font color="#067499">цвет заголовока</font>
        </h1> 

        
        </br></br>
        
        <!-- Как использовать рамку для вставки YouTube видео. 
        Мы также создадим раздел Follow Me, который включает ссылки в конце страницы.  -->
        
        <div>
                <h1><font color="C98C1A"><span>Бригитта</span></font></h1>
                <iframe src="https://www.youtube.com/embed/LWVIei59zVA?ecver=2" 
                width="320" height="180" frameborder="0" 
                allow="autoplay; encrypted-media" allowfullscreen></iframe>
        </div>

        </br></br> 
        
        <!-- Категории моделей контента

        В HTML элементы, как правило, были двух моделей: либо блочные, либо строчные. В HTML5 введены семь основных моделей контента.

        - Метаданные
        - Встроенный контент
        - Интерактивный контент
        - Заголовочный контент
        - Фразаобразующий контент
        - Потоковый контент
        - Секционирующий контент  
        
        Метаданные: Контент, который определяет представление или поведение остального контента на веб-странице. Эти элементы находятся в элементе head документа.
        Элементы: <base>, <link>, <meta>, <noscript>, <script>, <style>, <title>

        Встроенный контент: Контент, который импортирует другие ресурсы в документ.
        Элементы: <audio>, <video>, <canvas>, <iframe>, <img>, <math>, <object>, <svg>

        Интерактивный контент: Контент, специально предназначенный для взаимодействия с пользователем.
        Элементы: <a>, <audio>, <video>, <button>, <details>, <embed>, <iframe>, <img>, <input>, <label>, <object>, <select>, <textarea>

        Заголовочный контент: Создаёт заголовки.
        Элементы: <h1>, <h2>, <h3>, <h4>, <h5>, <h6>, <hgroup>

        Фразообразующий контент: К этой модели принадлежат несколько строчных элементов, по аналогии с HTML4.
        Элементы: <img>, <span>, <strong>, <label>, <br />, <small>, <sub> и прочие.
        
        Потоковый контент: Большинство HTML5 - элементов, входящих в эту группу, отвечают за обычное функционирование документа.

        Секционирующий контент: Отвечает за определение границ разделов на веб-странице (например, заголовков, подвала). 
        Элементы: <article>, <aside>, <nav>, <section> -->
        
        пример структуры веб страницы</br>
        <img src="http://html-css-evgeny-i-gurin.cs50.io/html-css-js/images/html.jpg" height="30%" width="30%" alt="структура html документа"/>
        
        </br></br>
        
        <!-- Элемент <header> следует помещать внутрь тега body   -->
        
        <header>
         <h1>Самый громкий заголовок</h1>  
         <h3>Не столь громкий заголовок</h3>
        </header>

      
        </br></br>
        
        <!--  Элемент <footer>

        Тоже широко используемый элемент. Обычно самая нижняя секция веб-страницы называется подвалом или футером.  -->
        
        <footer>элемент footer</footer>
        
        <!-- В эту пару тегов может заключаться:
        - Контактная информация 
        - Политика конфиденциальности 
        - Значки социальных медиа
        - Условия предоставления услуг 
        - Информация об авторских правах 
        - Карта сайта и сопутствующие документы -->
        
        </br></br>
        
        <!--  Элемент <nav>

        Этот тег отвечает за раздел страницы, в котором находятся ссылки на другие страницы или на другие разделы в пределах текущей страницы.  -->
        
        <nav>
           <ul>
              <li><a href="#">Домашняя страница</a></li>
              <li><a href="#">Услуги</a></li>
              <li><a href="#">О нашей компании</a></li>
           </ul>
        </nav>

        
        </br></br>
        
        <!--  Элемент article представляет автономный, независимый контент, который может использоваться и распространяться отдельно от своей страницы или сайта. 
        Это может быть сообщение на форуме, журнал или статья из газеты или блога, комментарий, интерактивный виджет или гаджет или любой другой независимый элемент контента. 
        
        Элемент <article> можно помещать внутрь другого элемента <article>. Такой вложенный элемент представляет контент, связанный с элементом снаружи. Например, 
        комментарии к статье в блоге могут быть элементами <article>, вложенными в другой элемент <article>, который представляет саму статью. -->
        
        <article> 
           <h1>Заголовок статьи</h1> 
           <p>Содержимое элемента article</p>
        </article>
        
        </br></br> 
        
        <!--  Элемент <section> - это логический контейнер страницы или статьи. 
        С его помощью содержимое элемента article разбивается на блоки, или разделы. 
        Домашняя страница, к примеру, может содержать: раздел с представлением компании, раздел с новостями и ещё один раздел с контактами.  

        Каждый блок <section> должен быть правильно указан: обычно проставляются теги заголовка (h1-h6), которые оформляются как его дочерние элементы.  -->
        
        <article>
           <h1>Добро пожаловать!</h1>
           <section>
              <h1>Заголовок</h1>
              <p>Некоторый контент</p>
           </section>
        </article>
        
        <!-- Если нужно оформить контент элемента <section> в отдельный раздел, рекомендуется использовать элемент <article>. -->
        
        </br></br> 
        
        <!--  Элемент <aside> служит для представления второстепенного или сопутствующего контента. Это контент, независимый от основного контента, но напрямую с ним связанный.
        Он обычно располагается в боковых панелях страницы.
        Когда тег <aside> используется внутри тега <article>, контент <aside> должен иметь непосредственное отношение к контенту <article>.  -->
        
        <article>
           <h1>Подарки на любой вкус!</h1>
           <p>На этом веб–сайте Вы найдёте лучшие в мире подарки!</p>
           <aside>
              <p>Доставка в течение 24 часов.</p>
           </aside>
        </article>
        
        
        </br></br>
        
        <!--  До HTML5 специального стандарта для проигрывания звуковых файлов в браузере не существовало.
        С введением элемента <audio> в HTML5 появился единый стандарт для встраивания звуковых файлов в веб-страницы.
        
        controls
        Указывает браузеру, что нужно отобразить элементы управления воспроизведением (кнопки начала/остановки воспроизведения и другие)

        autoplay
        Воспроизведение звукового файла начинается сразу же после загрузки страницы без надобности в разрешении пользователя.
        
        loop
        При использовании этого атрибута звуковой файл будет воспроизводится циклически.
        
        На сегодняшний день элемент <audio> поддерживает три формата: MP3, WAV и OGG.-->
        
        <audio src="audio.mp3" controls autoplay loop>
           Элемент audio не поддерживается Вашим браузером.
        </audio>
        
        </br>
        <!-- Элементы <source> могут быть привязаны к различным звуковым файлам. Браузер будет использовать тот формат, который был распознан первым.-->
        
        <audio controls>
                <source src="audio.mp3" type="audio/mpeg">
                <source src="audio.ogg" type="audio/ogg">
                Элемент audio не поддерживается Вашим браузером.
        </audio>
        
        </br></br> 
        
        <!--  В браузерах, не поддерживающих элемент <audio>, будет отображаться текст, помещённый между тегами <audio> и </audio>.  -->
        
        <audio controls>
           <source src="audio.mp3" type="audio/mpeg">
           <source src="audio.ogg" type="audio/ogg">
           Элемент audio не поддерживается Вашим браузером.
        </audio>
        
        
        </br></br> 
        
        <!--  Элемент video похож на элемент audio. 
        Путь к исходному видеофайлу указывается с помощью атрибута source внутри элемента video или с использованием элементов source внутри элемента video: 
        
        Ещё одна общая особенность элементов audio и video -  это одинаковые атрибуты: controls, autoplay и loop. 

        На сегодняшний день элементом <video> поддерживаются три формата: MP4, WebM и OGG.-->
        
        <video controls autoplay loop  width="400" height="300" >
           <source src="https://html-css-js-evgeny-i-gurin.cs50.io/html-css-js/images/video.mp4" type="video/mp4">
           <source src="video.ogg" type="video/ogg">
           Видео не поддерживается Вашим браузером
        </video>
        
        <!-- На сегодняшний день элементом <video> поддерживаются три формата: MP4, WebM и OGG. -->
        
        </br></br>
        
        <!--  Элемент <progress> используется для создания полосы выполнения на веб-странице.
        Его можно добавлять внутрь заголовков, абзацев или в любой раздел в теле страницы.

        Атрибуты элемента <progress>
        Value - указывает степень выполнения задачи 
        Max - указывает на общий размер задачи  -->
        
        Статус: <progress min="0" max="100" value="35"></progress>
        
        </br></br>
        
        веб-хранения
        <!-- Благодаря тому, что в HTML5 есть поддержка веб-хранения, данные веб-сайтов можно хранить на локальном компьютере пользователя. 
        До появления HTML5 в этих целях мы использовали куки-файлы JavaScript. 

        Преимущества веб-хранения данных
        - безопасней
        - быстрее
        - возможность сохранять больший объём данных 
        - хранимые данные не передаются при каждом серверном запросе
                   
        Есть два типа объектов веб-хранения:
        - sessionStorage()
        - localStorage()

        Сравнение: сессионное и локальное хранилище
        - в сессионном хранилище данные удаляются, как только пользователь закроет браузер
        - в локальном хранилище данные хранятся без ограничения по времени       
        
        
        Для локального и сессионного веб-хранения используются очень простые и похожие правила синтаксиса.
        Данные сохраняются в виде пары ключ/значение.

        Сохранение значения:
        localStorage.setItem("key1", "value1");        
        
        Извлечение значения:
        //чтобы показать значение
        alert(localStorage.getItem("key1"));

        Удаление значения:
        localStorage.removeItem("key1");
        
        Удаление всех значений:
        localStorage.clear();
        
        Такой же синтаксис используется и для сессионного хранения, с одним отличием: вместо localStorage используется sessionStorage. -->
        
        
        
        </br></br>
        
        геолокации
        
        <!-- В HTML5 API геолокации используется для установления географического местоположения пользователя.

        Так как это ставит под угрозу конфиденциальность пользователя, API работает только с его разрешения. 
        
        Основной метод API геолокации - getCurrentPosition, с помощью которого извлекается текущее 
        географическое местоположение пользовательского устройства. 
        
        navigator.geolocation.getCurrentPosition();
        
        Параметры:
        showLocation (обязательный) - назначает метод обратного вызова, с помощью которого извлекается информация о местоположении.
        ErrorHandler (по желанию) - назначает метод обратного вызова, который будет использоваться при возникновении ошибки при обработке асинхронного вызова.
        Options (по желанию) - назначает параметры извлечения информации о местоположении.
        
        Местоположение пользователя может быть представлено в двух видах: геодезическом и общественном.

        1. При геодезическом способе описания местоположения используется географические широта и долгота.
        2. При общественном способе местоположение представляется в более доступном для не специалиста виде.

        Каждый параметр содержит данные как геодезического, так и общественного видов
        
        Метод getCurrentPosition() показывает объект только в случае успеха запроса. Широта, долгота и степень точности показываются всегда.-->
        
        </br></br>
        
        <!-- Функция перетаскивания позволяет «захватить» объект и перетащить его в другое место.

        Чтобы элемент сделать перетаскиваемым, просто задайте атрибуту draggable значение true:  
        
        <img draggable="true" /> 
        
        Любой HTML - элемент может перетаскиваться.
        В API перетаскивания в HTML5 работает на основе событий.-->
        
        <p>переместите бригитту, сомбру и ангел в формы их цветов </p>
        
        <div style="width:100%">
                <div id="box1" ondrop="drop(event)" ondragover="allowDrop(event)"
                        style="border:2px solid orange; width:100px; height:150px; display: inline-block;">
                </div>

                <div id="box2" ondrop="drop(event)" ondragover="allowDrop(event)"
                        style="border:2px solid purple; width:100px; height:150px; display: inline-block;">
                </div>

                <div id="box3" ondrop="drop(event)" ondragover="allowDrop(event)"
                        style="border:2px solid brown; width:100px; height:150px; display: inline-block;">
                </div>
        </div>
        
        <img id="image1" src="https://d1u1mce87gyfbn.cloudfront.net/hero/brigitte/full-portrait.png" draggable="true"
        ondragstart="drag(event)" width="90px" height="150px" alt="" />
        
        <img id="image2" src="https://d1u1mce87gyfbn.cloudfront.net/hero/sombra/full-portrait.png" draggable="true"
        ondragstart="drag(event)" width="50px" height="150x" alt="" />
        
        <img id="image3" src="https://d1u1mce87gyfbn.cloudfront.net/hero/mercy/full-portrait.png" draggable="true"
        ondragstart="drag(event)" width="100" height="150px" alt="" />

        <!-- Что перетаскивать
        При перетаскивании элемента атрибут ondragstart вызывает функцию drag(event), которая определяет, какие данные должны быть перетащены.
        Метод dataTransfer.setData() назначает тип данных и значение перетаскиваемых данных:
        
        function drag(ev) {
           ev.dataTransfer.setData("text", ev.target.id);
        }
        
        В нашем примере тип данных - "text", а значение - идентификатор ID перетаскиваемого элемента (изображения "image"). 

        Куда сбросить
        Событие ondragover указывает, куда перетаскиваемый элемент должен быть сброшен. По умолчанию данные и элементы не могут быть сброшены на другие элементы. Чтобы завершить перетаскивание, нам нужно отменить поведение элемента, установленное по умолчанию.
        Для этого нужно назначить событию ondragover метод event.preventDefault(). 

        Сбрасывание
        Когда пользователь отпускает перетаскиваемый элемент, происходит событие drop.
        В приведённом выше примере атрибут ondrop вызывает функцию drop(event):

        function drop(ev) {
           ev.preventDefault();
           var data = ev.dataTransfer.getData("text");
           ev.target.appendChild(document.getElementById(data));
        }

        Метод preventDefault() предотвращает поведение браузера по умолчанию (то есть открыть перетаскиваемый элемент как ссылку).
        Чтобы получить перетаскиваемые данные используется метод dataTransfer.getData(). При применении этого метода будут извлечены все данные,
        тип которых соответствует тому, что был назначен в методе setData().
        Перетаскиваемые данные - это идентификатор ID перетаскиваемого элемента ("image").

        Наконец, при помощью функции appendChild() перетащенный элемент добавляется к коду элемента, в который он был сброшен.-->
        
        </br></br>
        
        <!--  SVG (Scalable Vector Graphics, или масштабируемая векторная графика) - язык разметки в стиле HTML для рисования фигур.

        Есть несколько методов рисования траекторий, прямоугольников, кругов, букв и графических изображений.   -->
        
        <img src="https://html-css-js-evgeny-i-gurin.cs50.io/html-css-js/images/linux.svg" alt="" height="300" />
        
        </br></br>
        
        <!--  Чтобы нарисовать фигуру с помощью SVG - графики, сначала нужно написать элемент svg с двумя атрибутами: шириной width и высотой height  
        
        <svg width="100" height="100"></svg> 
        
        Если нужно нарисовать круг, добавьте тег <circle>:  -->
        
        <svg width="300" height="100">
           <circle cx="100" cy="50" r="50" fill="green" />
        </svg>
        
        <!-- 
        - cx - центр круга передвигается вправо по экрану
        - cy - центр круга передвигается вниз по экрану
        - r - задаёт радиус
        - fill - задаёт цвет нашему кругу
        - stroke - для создания контура -->

        
        </br></br>
        
        <svg width="300" height="90">
           <rect width="200" height="50" x="50" y="20" fill="green" />
        </svg>
        
        </br></br>
        
        <!--  (x1, y1) задают координаты начала, (х2, у2) задают координаты конца линии.  -->
        
        <svg width="300" height="60">
           <line x1="50" y1="10" x2="250" y2="50" style="stroke:#000000; stroke-linecap:round; stroke-width:10" />
        </svg>
        
        </br></br>
        
        <svg width="400" height="60">
           <polyline style="stroke-linejoin:miter; stroke:black; stroke-width:12; fill: none;" points="50 10, 100 50, 200 10" />
        </svg>
        
        </br></br>
        
        <!-- Элемент <ellipse> пишется так же, как <circle>, с той лишь разницей, что: 
        Вы можете отдельно задавать координаты горизонтальной и вертикальной осей радиуса эллипса - с помощью атрибутов rx и ry.   -->
        
        <svg height="100" width="300">
           <ellipse cx="150" cy="50" rx="100" ry="50" style="fill:green" />
        </svg>
       
        </br></br> 
        
        <svg width="300" height="100">
                <polygon points="50 50, 100 100, 250 10" style="fill: green; stroke:black;" />
        </svg>
        
        </br></br>
        
        <!-- Анимация в SVG-графике создаётся с помощью элемента <animate>. -->
        
        <svg width="100%" height="150">
                <rect width="150" height="150" fill="red">
                   <animate attributeName="x" from="0" to="100%" dur="6s" fill="freeze" repeatCount="3"/> 
                </rect>
                <rect width="150" height="150" fill="green">
                   <animate attributeName="x" from="100%" to="0%" dur="7s" fill="freeze" repeatCount="2"/> 
                </rect>
                <rect width="150" height="150" fill="blue">
                   <animate attributeName="x" from="0%" to="100%" dur="3s" fill="freeze" repeatCount="6"/> 
                </rect>
        </svg>
        
                <!--    attributeName - указывает, к какому атрибуту будет применяться анимация
                from - назначает стартовое значение атрибута
                to - назначает конечное значение атрибута
                dur - назначает длительность анимации
                fill - указывает, должно ли значение атрибута вернуться к своему первоначальному значению после завершения анимации 
                (значения: "remove" сбрасывает значение; "freeze" - сохраняет значение "to")
                repeatCount - назначает количество повторов анимации
                Чтобы анимация повторялась бесконечно, атрибуту repeatCount задаётся значение "indefinite".  -->
        
        </br></br>
        
        <!--  Элемент <path> используется для указания траектории.

        С элементом path можно использовать следующие команды:
        M: moveto
        L: lineto
        H: horizontal lineto
        V: vertical lineto
        C: curveto
        S: smooth curveto
        Q: quadratic Bézier curve
        T: smooth quadratic Bézier curveto
        A: elliptical Arc
        Z: closepath

        Траекторию указываем атрибутом d:  -->
        
        <svg width="300" height="200">
                <path d="M 0 0 L200 200 L200 0 Z" style="stroke:#000; fill:none;" />
        </svg>
        
        <!--
        М устанавливает нашу «виртуальную ручку» в положение (0, 0). «Ручка» затем двигается по диагонали вниз и вправо на 200 пикселей, 
        затем вверх в положение (200, 0). Команда Z замыкает фигуру, создаётся гипотенуза
        Во всех вышеперечисленных командах также могут использоваться строчные буквы. Заглавные буквы назначают абсолютное положение,
        буквы в нижнем регистре назначают относительное положение. -->
        
        </br></br>
        
        <!--  С помощью элемента canvas в HTML рисуется графика всех типов сложности: от простых линий до сложных графических объектов.

        Элемент canvas оформляется следующим образом:  
        <canvas id="canvas1" width="200" height="100"></canvas> 
        
        Элемент <canvas> должен иметь атрибут id для привязки в JavaScript:-->
        
        <canvas id="canvas1" width="100" height="100"></canvas> 
        <script>
                var canvas=document.getElementById("canvas1");
                var ctx=canvas.getContext("2d");
                ctx.fillStyle ="rgba(0, 200, 0, 1)";
                ctx.fillRect (36, 10, 22, 22);
        </script>
        
        <!-- С помощью метода getContext() получаем контекст рисования на холсте. 
        
        Посредством метода fillRect(x, y, w, h) рисуется «залитый» прямоугольник, при этом w - его ширина и h - его высота.
        По умолчанию используется чёрный цвет заливки. 

        Здесь на холсте в позиции (20, 20) будет нарисован чёрный прямоугольник размером 100х100 пикселей:
        
        var c=document.getElementById("canvas1");
        var ctx=c.getContext("2d");
        ctx.fillRect(20,20,100,100);
        
        Свойство fillStyle задаст цвет, градиент или узор заливки рисунка.
        С помощью этого свойства Вы можете нарисовать, например, зелёный прямоугольник.
        
        var canvas=document.getElementById("canvas1");
        var ctx=canvas.getContext("2d");
        ctx.fillStyle ="rgba(0, 200, 0, 1)";
        ctx.fillRect (36, 10, 22, 22);
        
        На холсте в HTML можно рисовать с помощью и других методов:

        Нарисовать линию
        moveTo(x,y) - задаёт стартовую точку линии
        lineTo(x,y) - задаёт конечную точку линии

        Нарисовать круг 
        beginPath() - начинает рисовать
        arc(x,y,r,start,stop) - задаёт параметры круга
        stroke() - заканчивает рисовать

        Градиенты 
        createLinearGradient(х, у, x1, y1) - создаёт объект линейного градиента
        createRadialGradient(x,y,r,x1,y1,r1) - создаёт объект кругового градиента

        Нарисовать текст на холсте
        Font - задаёт параметры шрифта
        fillText(text,x,y) - рисует «залитый» текст на холсте
        strokeText(text,x,y) - рисует текст на холсте без заливки-->

        </br></br>
        
        Сравнение: холст и SVG - графика
        
        <!--   Сравнение: холст и SVG - графика

        Холст:
        - объекты рисуются программным способом 
        - рисование на основе пикселей
        - анимация не встроена
        - быстрая обработка операций рисования на основе пикселей
        - нужно принимать во внимание разрешение
        - нет поддержки обработчиков событий
        - возможность сохранить получившееся изображение в формате .png или .jpg 
        - хорошо подходит для игр со сложной графикой

        SVG 
        - элементы являются частью модели DOM (объектной модели документа) страницы
        - рисование осуществляется с помощью векторов 
        - встроены эффекты, такие как анимация
        - на основе более понятного стандартного синтаксиса XML
        - не нужно принимать во внимание разрешение
        - реализована поддержка обработчиков событий 
        - не подходит для игровых приложений
        - лучше всего подходит для приложений с большой областью отображения (например, Google Maps)
        
        В принципе, можно использовать SVG-графику и холст вместе на одной странице, если это необходимо.
        Тем не менее, нельзя рисовать векторные изображения поверх холста или наоборот.-->
        
        </br></br>
        
        Элемент canvas можно трансформировать.
        
        <!--   Элемент canvas можно трансформировать. В качестве примера мы написали некоторый текст на холсте в позиции (20, 10). 
        
        ctx.font="bold 22px Tahoma";
        ctx.textAlign="start";
        ctx.fillText("start", 10, 30);
        
        Метод translate(x,y) используется для перемещения холста. х указывает, как далеко нужно переместить сетку по горизонтали, 
        а у — как далеко нужно переместить сетку по вертикали.
        
        ctx.translate(100, 150);
        ctx.fillText("after translate", 10, 30);
        
        Метод rotate() используется для вращения холста в HTML5. Параметр задаётся в радианах, а не градусах.

        В примере внизу показан один и тот же прямоугольник до и после применения вращения:
        
        ctx.fillStyle = "#FF0000";
        ctx.fillRect(10,10, 100, 100);

        ctx.rotate( (Math.PI / 180) * 25); //поворот на 25 градусов.

        ctx.fillStyle = "#0000FF";
        ctx.fillRect(10,10, 100, 100);
        
        Метод scale() масштабирует текущий рисунок. Требует два параметра:
        - во сколько раз изображение должно быть масштабировано вдоль оси X
        - во сколько раз изображение должно быть масштабировано вдоль оси Y
        
        var canvas = document.getElementById('canvas1');
        ctx =canvas.getContext('2d');
        ctx.font="bold 22px Tahoma";
        ctx.textAlign="start";
        ctx.fillText("start", 10, 30);
        ctx.translate(100, 150);
        ctx.fillText("after translate", 0, 0);
        ctx.rotate(1);
        ctx.fillText("after rotate", 0, 0);
        ctx.scale(1.5, 4);
        ctx.fillText("after scale", 0,20);
        
        В результате холст будет масштабирован в 1,5 раза вдоль оси X и в 4 раза вдоль оси Y  -->
        
        </br></br>
        
        <!-- HTML5 привносит много новых возможностей и совершенствований в технологию веб-форм. 
        С целью повышения удобства просмотра веб-страниц были разработаны и добавлены новые атрибуты и способы ввода данных.  -->
        
        <form>
           <label>Ваше имя:</label>
           <input id="user" name="username" type="text" />
        </form>
        
        
        </br></br> 
        
        <!--  В HTML5 появился новый атрибут заполнителя placeholder. 
        В элементах <input> и <textarea> этот атрибут содержит подсказку для пользователя о том, 
        какая информация может быть введена в данное поле.  -->
        
        <form>
           <label for="email">Ваш электронный адрес: </label> 
           <input type="text" name="email" placeholder="email@example.com" /> 
        </form>
        
        </br></br> 
        
        <!--  Атрибут autofocus ставит курсор в нужное поле ввода, когда форма загрузится:  -->
        
        <form>
           <label for="e-mail">Ваш электронный адрес: </label> 
           <input type="text" name="email" autofocus placeholder="автофокус"  />
        </form>
        
        </br></br>
        
        <!--  Атрибут required используется, когда нужно сделать поля ввода обязательными для заполнения.  -->
        
        <form autocomplete="off">
           <label for="e-mail">Ваш электронный адрес: </label> 
           <input name="Email" type="text" required /> 
           <input type="submit" value="Submit"/> 
        </form>
        
        <!-- Атрибут autocomplete используется, когда нужно указать, будет ли работать функция автозаполнения формы.
        Когда автозаполнение включено, браузер автоматически заполнит поля, исходя из ранее введённых пользователем данных.

        В HTML5 добавлены новые поля ввода input type:
        - color
        - date
        - datetime
        - datetime-local
        - email
        - month
        - number
        - range
        - search
        - tel
        - time
        - url
        - week

        Новые атрибуты полей ввода в HTML5:
        - autofocus
        - form
        - formaction
        - formenctype
        - formmethod
        - formnovalidate
        - formtarget
        - height and width
        - list
        - min and max
        - multiple
        - pattern (regexp)
        - placeholder
        - required
        - step   -->
        
        
        
        
        </br></br>
        
        <!--  Новый тип поля ввода search служит для создания окна поиска:  -->
        
        <input id="mysearch" name="searchitem" type="search" />
        
        </br></br>
        
        <!--  Тег <datalist> может быть использован, чтобы задать список предопределённых параметров поиска:  -->
        
        <input id="car" type="text" list="colors" />
        <datalist id="colors">
           <option value="Красный">
           <option value="Зелёный">
           <option value="Желтый">
        </datalist>
        
        <!--  С помощью <option> создаются варианты выбора, которые будут предложены пользователю в выпадающем списке. 
        
        
        Идентификатор ID элемента datalist должен совпадать с атрибутом list в элементе input.-->
        
        </br></br>
        
        <!--  Среди других новых типов полей ввода - email, url и tel:  -->
        
        <input id="email" name="email" type="email" 
                placeholder="example@example.com" />
        <input id="url" name="url" type="url" 
                placeholder="example.com" />
        <input id="tel" name="tel" type="tel" 
                placeholder="555.555.1211" />
        
        <!--  Они будут особенно полезны при просмотре страницы на современном мобильном устройстве: 
        устройство распознает тип поля ввода и откроет нужную клавиатуру. 
        
        Новые типы полей ввода облегчают сортировку и проверку данных, отправляемых в HTML-формах.-->
        
        </br>
        </br>
        </br>
        </br>
        </br>
        </br>
        </br>
        </br>
        </br>
        
    </body>
</html> 


























































































































